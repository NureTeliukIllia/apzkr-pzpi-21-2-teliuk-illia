Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації крафтового пивоваріння.

Студент гр. ПЗПІ-21-2	__________________ Телюк І. О.
(підпис)
Керівник роботи	__________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)


Харків 
2024 р.
 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6				____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Телюку Ілля Олександровичу
1.	Тема роботи: «Програмна система для автоматизації крафтового пивоваріння»	
2.	Термін узгодження завдання курсової роботи «25» березня 2024 р.
3.	Термін здачі студентом закінченої роботи «14» червня 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
унікальність,  актуальність, розповсюдженість, масштабованість, локалізація, адміністрування системи, реалізація трьох компонентів (Back-end, Front-end, IoT)	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування бази даних,архітектура програмної системи, опис програмної системи, висновки, перелік джерел посилання, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень), ER-діаграма бази даних, логічна схема бази даних, діаграма прецедентів, діаграма розгортання, діаграма пакетів, діаграма взаємодії, діаграма діяльності,  діаграма компонентів	
 
КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проєкту	31.03.2024	
2	Проєктування програмного
проєкту	11.04.2024	
3	Кодування програмного проєкту	30.05.2024	
4	Оформлення пояснювальної
записки	10.6.2024	
5	Захист курсової роботи	14.06.2024	

Дата видачі завдання «24» березня 2024 р.
Керівник	__________________ доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	                 Телюк І. О.
(підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 94 с., 33 рис., 2 табл., 4 додатки, 6 джерел. 
АВТОМАТИЗАЦІЯ, ПИВОВАРІННЯ, АДМІНІСТРАТОР, ПИВОВАР, ОБЛАДНАННЯ, ІНГРЕДІЄНТ, РЕЦЕПТ, КОНТРОЛЬ ПРОЦЕСУ, ПРОГРАМНА СИСТЕМА.
Об’єктом дослідження є галузь крафтового пивоваріння, а саме розробка програмної системи для автоматизації процесу виробництва пива вдома з використанням сучасних технологій IoT та забезпеченням інтерфейсу для користувачів.
Метою курсової роботи є створення програмної системи, яка дозволяє автоматизувати моніторинг та керування процесом виготовлення пива вдома. Система забезпечить користувачів можливістю створювати та зберігати рецепти, контролювати та відстежувати параметри процесу варіння, отримувати сповіщення про стан варіння та аналізувати дані процесу.
Методи розробки базуються на інтеграції IoT-пристроїв з програмним забезпеченням, використанні веб-технологій для реалізації інтерфейсу користувача та мов програмування для розробки вбудованих систем.
У результаті роботи розроблено програмну систему для автоматизації виготовлення пива вдома. Система включає веб-додаток для користувачів, сервер для обробки даних та інтеграції з IoT-пристроями, а також систему адміністрування для налаштування та керування системою. 
ЗМІСТ
	

Вступ	7
1 Аналіз предметної області	8
    1.1 Бізнес-вимоги	8
        1.1.1 Бізнес-можливості	8
        1.1.2 Бізнес-цілі та критерії успіху	9
        1.1.3 Потреби клієнтів або ринку	9
        1.1.4 Бізнес-ризики	1010
    1.2 Концепція рішення	11
        1.2.1 Окреслення концепції	11
        1.2.2 Головна функціональність	12
        1.2.3 Припущення та залежності	133
    1.3 Рамки та обмеження проєкту	155
        1.3.1 Рамки первинного випуску	155
        1.3.2 Рамки наступних випусків	16
        1.3.3 Обмеження та винятки	17
    1.4 Бізнес-контекст	17
        1.4.1 Профілі зацікавлених сторін	17
        1.4.2 Пріоритети проєкту	18
        1.4.3 Робоче середовище	19
2 Постановка задачі	21
3 Проєктування бази даних	23
    3.1 Побудова ER-діаграми	233
    3.2 Побудова логічної моделі бази даних на основі ER-діаграми	24
4 Архітектура програмної системи	29
    4.1 Архітектура серверної частини	29
    4.2 Архітектура IoT частини	32
    4.3 Архітектура клієнтської частини	37
5 Опис програмної системи	43
    5.1 Виклик і завантаження	43
    5.2 Призначення і логічна структура	45
    5.3 Опис програмної реалізації	46
Висновки	56
Перелік джерел посилання	57
Додаток А Результат перевірки на плагіат	58
Додаток Б Програмний код серверної частини	59
Додаток В Програмний код IoT пристрою	69
Додаток Г Програмний код клієнтської частини	76
 
ВСТУП


Пивоваріння відзначається тисячолітньою історією, протягом якої технологічний прогрес постійно змінював процес виробництва пива. Хоча великі виробники вдалися до автоматизації своїх заводів, малі виробники та любителі пива залишаються з питанням: як забезпечити якість без великих витрат?
Виробництво високоякісного пива вимагає уваги до численних параметрів, таких як температура, вологість, кислотність, тиск та інші. Звичайна людина не може відслідковувати всі ці фактори, тому потрібно знайти рішення.
Наша програмна система ставить за мету надати більш зручне та сучасне обладнання для крафтового пивоваріння, яке дозволить користувачам максимально контролювати процес та мати доступ до необхідних даних.
Цей продукт є своєрідним свіжим подихом для світу пивоваріння, поєднуючи в собі технологічний прогрес та базові інструменти, щоб дати можливість творити пивоварні шедеври без зайвих зусиль.
 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


Аналоги на ринку:
	Brewman Brewery Solutions: рішення від цієї компанії призначені для великих підприємств, які спеціалізуються на масовому виробництві пива. Вони забезпечують якість та контроль на виробництві, але не надають інструментів для відслідковування процесів на різних платформах. Крім того, у порівнянні з конкурентами, в компанії відсутній каталог рецептів.
	Minibrew: це компактна пивоварня, яка має невеликі розміри і може поміститися навіть на кухні, порівняно з розмірами кавомашини. Однак у цього конкурента є деякі недоліки. По-перше, обмежений асортимент розмірів машини, що ускладнює використання для барів, які мають більші потреби. По-друге, хоча в самій машині автоматизовано багато процесів, відсутній інтерактив з мобільним додатком, що робить важко відслідковувати стан процесу.
У сегменті більш доступних рішень різноманітні компанії пропонують прості варіанти, такі як одна кега з кількома кранами, проте вони не забезпечують якість або наявність інтелектуальних функцій. Наша система виділятиметься за такими основними факторами:	
	кросплатформеність;
	віддалене керування та моніторинг процесу;
	простий доступ до обладнання, матеріалів, рецептів тощо через нашу компанію;
	можливість подальшого аналізу даних.
Серед недоліків варто відзначити високу залежність від Інтернету та технологій.

1.1.2 Бізнес-цілі та критерії успіху
BO-1: Досягти успішного входу на ринок та збільшити темпи продажів.
SC-1: Протягом перших 6 місяців досягти бюджетного профіту та забезпечити мінімальний щомісячний зріст продажів на 5%.
BO-2: Закріпити позиції на ринку.
SC-2: Кожен квартал досягати зростання продажів на 13%.
BO-3: Збільшити попит на рецепти крафтового пива.
SC-3: Протягом перших 6 місяців подвоїти обсяги продажів рецептів.
BO-4: Збільшити попит на додаткове обладнання.
SC-4: Кожен п'ятий клієнт має намір придбати додаткові інструменти з внутрішнього магазину компанії.
BO-5: Розширити асортимент солодів та здобути нових клієнтів.
SC-5: З розширеним асортиментом солодів спостерігається зростання замовлень на 5% щомісяця.


1.1.3 Потреби клієнтів або ринку


а)  Потреби клієнтів: У програмній системі можна виділити два типи користувачів:
	пивовари, які виробляють пиво вдома: особи, які самостійно варять пиво та шукають зручне рішення для моніторингу та забезпечення ідеальних умов в процесі варіння.
	малі пивоварні: невеликі пивоварні, які виробляють пиво або працюють у масштабі невеликої пивоварні, і потребують ефективного моніторингу та керування виробництвом.  
б)  Ринковий попит: Зростаючий попит на програмні системи для автоматизації крафтового пивоваріння внаслідок зростання інтересу до домашнього пивоваріння та розвитку малих пивоварень.
в) Невиконані потреби: Існують недоліки у традиційних методах виготовлення крафтового пива, які потребують зручного керування та не забезпечують можливості для систематичного моніторингу та отримання сповіщень.
г)  Сценарії використання:
	користувачі створюють профілі пивоварень у системі, вказуючи конкретні умови виробництва для кожного виду пива.
	система взаємодіє з датчиками, розташованими у бочках або на обладнанні, для постійного моніторингу температури та інших параметрів виробництва
	користувачі отримують сповіщення на сторінці обладнання щодо необхідності коригування процесу виробництва пива або відхилень від стандартних умов.


1.1.4 Бізнес-ризики


Конкуренція на ринку:
Ризик: З високою конкуренцією може виникнути ускладнення входу на ринок та залучення користувачів до нашого продукту;
Рішення: Розробка унікальної функціональності та особливостей продукту, які роблять його видатним серед конкурентів.
Залежність від сторонніх постачальників:
Ризик: Надмірна залежність може стати критичною для компанії у випадку проблем з постачанням;
Рішення: Укладання договорів з гарантіями, створення резервів ресурсів та диверсифікація постачальників.


Технічні проблеми:
Ризик: Виникнення технічних неполадок може призвести до недієздатності системи;
Рішення: Проведення регулярного технічного обслуговування компонентів системи та створення резервних копій даних.
Відмова клієнтів:
Ризик: Незадоволення клієнтів продуктом може призвести до збитків або навіть банкрутства;
Рішення: Надання інформаційної підтримки, збір зворотного зв'язку від користувачів та оперативна реакція на виявлені недоліки у системі та їх виправлення.


1.2 Концепція рішення
1.2.1 Окреслення концепції


Проєкт має на меті впровадження автоматизації процесу виготовлення пива вдома. Програмна система надасть можливість початківцям пивоваріння зручно варити пиво, передаючи керування процесом системі.
Головними перевагами продукту є зменшення фізичних зусиль, необхідних для контролю обладнання під час варіння, поліпшений моніторинг параметрів процесу завдяки IoT-пристроїв та власній системі. У галузі, де раніше відсутні були інтерфейси, клієнт отримує надзвичайно зручний користувацький досвід, візуалізацію даних щодо його варіння.
Таким чином, створення програмної системи для автоматизації власноручного пивоваріння допоможе пивоварам досягти відмінних результатів з меншими зусиллями та збільшити їх задоволення від процесу.


1.2.2 Головна функціональність
	

MF1.	Автоматизований моніторинг:
Система автоматично вимірює та відстежує:
	температуру сусла в чанах та бродильних ємностях.
	вологість повітря в приміщенні пивоварні.
	тиск в танках дображивания.
	рівень рідини в ємностях.
	етап пивоваріння.
Датчики автоматично надсилають повідомлення на пошту:
	при виході показників за межі заданих діапазонів.
	при настанні критичних подій (наприклад, закисання сусла).
	при завершенні процесу пивоваріння.
MF2.	Персоналізовані профілі рецептів:
Користувачі можуть створювати і зберігати унікальні профілі для кожного 	рецепту:
	створювати замовлення додаткового обладнання, купівля рецептів,	видаткових матеріалів.
	створювати та публікувати власні рецепти.
	вказувати задані значення температури, вологості, тиску та рівня для 	кожного етапу пивоваріння.
	додавати нотатки та спостереження за процесом пивоваріння.
	зберігати історію пивоваріння для порівняння та аналізу результатів.
	отримувати зручний доступ для користувачів з різних пристроїв.
	відстежувати процес пивоваріння в будь-якому місці та в будь-який час.
MF3.	Сповіщення  та аналітика:
Система надсилає сповіщення користувачам:
	про порушення заданих параметрів пивоваріння.
	про наближення або настання критичних подій.
	про завершення процесу пивоваріння.
Аналітика даних у вигляді графіків та таблиць:
	дозволяє користувачеві легко порівнювати та відстежувати зміни показників.
	виявляти закономірності та оптимізувати процес пивоваріння.
MF4.      Адміністрування системи:
Роль адміністратора:
	можливість оновлювати асортимент обладнання та інгредієнтів.
	налаштовувати доступ до рецептів та даних.
 Підтримка різних датчиків:
	датчики температури.
	датчики вологості.
	датчики тиску.
	датчики рівня рідини.
MF5.     Керування датчиками:
	додавати та видаляти датчики.
	налаштовувати параметри датчиків.
	переглядати дані датчиків у реальному часі.
      	MF6.      Локалізація та мовна підтримка:
Система підтримує:
	українську, німецьку та англійську мови.
	інші мови можуть бути додані за запитом.


1.2.3 Припущення та залежності


П-1: Попит на простіше пивоваріння та кращу якість пива:
	клієнти прагнуть до більш зручного та безпроблемного процесу пивоваріння.
	зростає потреба у кращому контролі та прогнозованості результатів пивоваріння.
	очікується отримання пива вищої якості та кращого смаку.
П-2: Технічні вимоги до системи:
	для роботи системи необхідне підключення до електромережі.
	стійке інтернет-з'єднання є важливим для забезпечення роботи системи.
	система потребує наявності певного обладнання для пивоваріння.
З-1: Залежність від зовнішніх факторів:
	функціонування системи залежить від наявності та стабільності електропостачання.
	стійка робота інтернет-з'єднання є ключовою для доступу до сервера та керування системою.
З-2: Залежність від обладнання:
	ефективність та безперебійна робота системи залежить від стану та справності обладнання.
	необхідне регулярне технічне обслуговування та заміна зношених компонентів.
З-3: Правові аспекти:
	виробництво пива в Україні регулюється законодавством.
	система та процес пивоваріння повинні відповідати чинним нормам та вимогам. 
1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Серверна частина:
	реєстрація та авторизація користувачів: система має забезпечити можливість реєстрації та входу користувачів з різними ролями та рівнями доступу;
	API для IoT-пристрою: обробка даних та зберігання інформації про вологість, температуру та інші показники в базі даних;
	функціонал для управління профілем користувача та редагуванням інформації про нього;
	сесії варіння пива: можливість отримання та редагування інформації про сесії варіння, включаючи назву, рецепт та оцінку результату;
	рецепти: можливість придбати рецепт в магазині, де будуть представлені як власні рецепти компанії, так і рецепти інших користувачів, а також можливість створення та публікації власного рецепту;
	статистика: отримання інформації про середню тривалість сесій варіння, улюблені сорти пива, середню оцінку смаку тощо;
	магазин: можливість онлайн замовлення додаткового обладнання та матеріалів, таких як солод, дріжджі, ферменти;
	персоналізоване замовлення: можливість звернутися до нас напряму, заповнивши форму з необхідною інформацією;
	адміністрування: управління користувачами, магазином обладнання, рецептами, матеріалами та ролями.
Вебсайт:
	веб-інтерфейс для клієнтів: зручна взаємодія з системою через браузер;
	локалізація та інтернаціоналізація: підтримка різних мов та інформаційних стандартів для комфортного використання в різних регіонах
IoT-пристрій:
	збір даних про вологість та температуру і їх передача на сервер через HTTP-запити.


1.3.2 Рамки наступних випусків


Серверна частина:
	використання алгоритмів машинного навчання для генерації рекомендацій щодо параметрів процесу, ґрунтуючись на оцінках попередніх сесій;
	підвищення ефективності контролю навколишнього середовища шляхом заміни умовних блоків на алгоритми штучного інтелекту;
	розширення програмного інтерфейсу для IoT-пристроїв для виміру кислотності, лужності та кількості ферментів;
	виконання невеликих оновлень кодової бази для імплементації функціоналу інших складових системи.
Вебсайт:
	представлення рекомендацій для сесій, які будуть зберігатися на сервері;
	розширення сайту за допомогою розділу "Новини і анонси".
IoT-пристрій:
	розширення можливостей датчиків для виміру кількості ферментів, рівня кислотності та лужності;
	додавання звукових сигналів для позначення початку, завершення роботи, виявлення помилок та інших подій.
1.3.3 Обмеження та винятки


Залежність від доступу до електроенергії:
Обмеження: Потреба у стабільному джерелі електроенергії для неперервної роботи системи;
Виняток: В систему включено акумулятор або генератор для забезпечення роботи у випадку надзвичайних ситуацій.
Збій Інтернет-з'єднання:
Обмеження: Втрата Інтернет-з'єднання може перешкодити передачі даних на сервер і отриманню оновлень;
Виняток: Система має механізм автономної роботи та можливість зберігання даних локально до відновлення зв'язку.
Обмежені ресурси сервера:
Обмеження: Недостатні обчислювальні ресурси на сервері можуть вплинути на продуктивність системи;
Виняток: Система повинна мати можливість масштабування, і, можливо, буде необхідна додаткова інфраструктура для роботи з великим обсягом даних.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


На таблиці 1.1 описані профілі зацікавлених сторін:




Таблиця 1.1 – Профілі зацікавлених сторін 
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Клієнт	Обмеження бюджету та обмеження розміру приміщення	Досягнення високої якості продукту	Отримання смачного та якісного продукту з мінімальними затратами часу	Автоматизація процесу варіння пива та зручне використання системи
Інвестори	Обмеження бюджету	Фінансовий стимул	Позитивне очікування отримання значних прибутків від продажів	Потенційно прибутковий проект
Поставники	Обмеження ресурсів, обмеження у транспортуванні	Фінансовий стимул	Очікування отримання великої кількості замовлень товарів	Проект, який може сприяти налагодженню надійного та тривалого співробітництва


1.4.2 Пріоритети проєкту


На таблиці 1.2 наведені основні пріорітети проєкту:

Таблиця 1.2 – Основні пріорітети проєкту 
Показник	Опис	Пріорітет
План робіт	Реліз версії 1.0 повинен бути доступний до 10.06.2024.	Високий
Функціональність	Наявність всього зазаначеного функціоналу версії 1.0
	Високий
Якість	Система має забезпечувати стабільну роботу, безперебійно функціонувати і бути доступною в будь-який момент.	Високий
Персонал	Команда складається з однієї особи	Середній
Ціна	Бюджет обмежено, але може бути перевищений на до 15%	Середній


1.4.3 Робоче середовище


Програмна система буде використовуватися користувачами з різних країн, тому надзвичайно важливо забезпечити безперебійний доступ. Це буде забезпечено за допомогою хмарних сервісів Amazon Web Service. В робочому середовищі основні компоненти представлені наступним чином:
	 мова програмування: Система буде розроблена з використанням мови програмування C#, що забезпечить швидке та ефективне виконання завдань [1].
	база даних: Для забезпечення безпеки даних було обрано PostgreSQL як систему управління базами даних, оскільки вона відповідає вимогам GDPR щодо захисту даних користувачів і пропонує різноманітні механізми захисту, такі як ролева автентифікація та шифрування даних [2]. Доступ до цієї бази даних буде здійснюватися через бібліотеку Entity Framework Core, яка забезпечує високий рівень безпеки та швидкість роботи.
	фреймворк: Серверна частина буде розроблена з використанням ASP.NET, що забезпечить високу ефективність додатку [3].
	користувацький інтерфейс: Для створення клієнтської частини проекту буде використана бібліотека React з використанням мови програмування TypeScript [4].
	пристрій IoT: Для реалізації IoT-частини продукту буде використано ASP.NET.
	забезпечення безпеки: Планується використання протоколу HTTPS для забезпечення зашифрування даних під час їх передачі, а також впровадження сучасних методів аутентифікації та авторизації для захисту від несанкціонованого доступу.
	доступність та надійність: Система буде розміщена на сервері Azure з можливістю створення резервних копій та аварійного відновлення. Застосунок буде доступний для користувачів цілодобово без значних перерв у роботі.
 
2 ПОСТАНОВКА ЗАДАЧІ


Згідно з попереднім аналізом предметної області, завданням курсової роботи стало створення програмної системи для автоматизації процесу крафтового пивоваріння.
База даних повинна включати інформацію про: користувачів, ролі, рецепти, обладнання, інгредієнти, процеси пивоваріння та логи до них.
Для клієнта має бути реалізований наступний функціонал:
	Створення та редагування власного акаунту.
	Перегляд доступного обладнання, інгредієнтів, рецептів, а також списку власного обладнання, створених рецептів і наявних інгредієнтів.
	Додавання обладнання та інгредієнтів до інвентаря, створення, редагування та видалення власних рецептів, оцінення рецептів інших користувачів.
	Підключення до придбаного обладнання, отримання актуального статусу обладнання, запуск процесу приготування обраного рецепту на обладнанні.
Для адміністратора системи має бути реалізований наступний функціонал:
	Створення та редагування власного акаунту.
	Перегляд доступного обладнання, інгредієнтів, рецептів, а також списку власного обладнання, створених рецептів і наявних інгредієнтів.
	Додавання обладнання та інгредієнтів до інвентаря, створення, редагування та видалення власних рецептів, оцінення рецептів інших користувачів.
	Підключення до придбаного обладнання, отримання актуального статусу обладнання, запуск процесу приготування обраного рецепту на обладнанні.
	Перегляд, створення, редагування та видалення доступного обладнання та інгредієнтів.
	Створення резервних копій даних системи та їх імпорт.
Програмна система має підтримувати локалізацію та інтернаціоналізацію, зокрема: різні кодові таблиці символів, обчислення та формат дати й часу, місцевий та універсальний час, метричні й імперські одиниці вимірювання, порядок сортування тексту, різні напрями введення тексту тощо.
 
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


На основі аналізу предметної області були визначені основні сутності та встановлені їх зв’язки, які представили у вигляді ER-діаграми. (див. рис. 3.1).

 
Рисунок 3.1 – ER-діаграма бази даних

Сутність Пивовари – це сутність, яка містить інформацію про користувачів системи, і пов’язана зв’язком «один-до-багатьох» із сутністю Рецепти, зв’язком «багато-до-багатьох» із сутністю Обладнання та зв’язком «багато-до-багатьох» із сутністю Інгредієнти.
Сутність Інгредієнти – це сутність, що містить інформацію про інгредієнти, які можуть мати містити в собі рецепти та мати пивовари в інвентарі, і пов’язана зв’язком «багато-до-багатьох» із сутністю Рецепти та зв’язком «багато-до-багатьох» із сутністю Пивовари..
Сутність Рецепти – це сутність, що містить інформацію про рецепти, які створюються пивоварами, і пов’язана зв’язком «один-до-багатьох» із сутністю Поїздки.
Сутність Обладнання – це сутність, що містить інформацію про обладнання для пивоварінь, і пов’язана із сутностями Пивоваріння зв’язком «один-до-багатьох» та із сутністю Пивовари зв’язком «багато-до-багатьох».
Сутність Пивоваріння – це сутність, що містить інформацію про процеси пивоваріння обраного рецепта на обладнанні, і пов’язана із сутністю Рецепти, сутністю Обладнання та сутністю Логи_Пивоваріння зв’язком «один-до-багатьох».
Сутність Логи_Пивоваріння – це сутність, що містить інформацію про всі логи в процесі пивоваріння, які описують зміни в процесі, і пов’язана із сутністю Пивоваріння зв’язком «один-до-багатьох».


3.2 Побудова логічної моделі бази даних на основі ER-діаграми


Для забезпечення нормалізації бази даних, варто усунити зв’язки «багато-до-багатьох» між сутностями Пивовари та Обладнання, сутностями Пивовари та Інгредієнти, сутностями Інгредієнти та Рецепти. Для цього створимо проміжні сутності Пивовари_Обладнання, Пивовари_Інгредієнти, Рецепти_Інгредієнти.
Отже, у логічній моделі бази даних будуть представлені такі сутності:
	пивовари (Brewers);
	інгредієнти (Ingredients);
	рецепти (Recipes);
	обладнання (BrewingEquipment);
	пивоваріння (Brewings);
	логи_пивоваріння (BrewingLogs);
	пивовари_обладнання (BrewerBrewingEquipment);
	пивовари_інгредієнти (BrewerIngredients).
	рецепти_інгредієнти (RecipeIngredients).
Створимо таблицю пивоварів (Brewers). Вона буде містити у собі такі атрибути: brewer_id (первинний ключ), email, first_name, last_name.
Перевіримо таблицю Brewers на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю інгредієнтів (Ingredients). Вона буде містити у собі такі атрибути: ingredient_id (первинний ключ), name, price.
Перевіримо таблицю Ingredients на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю рецептів (Recipes). Вона буде містити у собі такі атрибути: recipe_id (первинний ключ), brewer_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Brewers), title, description.
Перевіримо таблицю Recipes на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю обладнання (BrewingEquipment). Вона буде містити у собі такі атрибути: equipment_id (первинний ключ), name, description, price.
Перевіримо таблицю BrewingEquipment на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю пивоваріння (Brewings). Вона буде містити у собі такі атрибути: brewing_id (первинний ключ), status, brewer_equipment_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею BrewingEquipment), recipe_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Recipes). 
Перевіримо таблицю Brewings на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю логів пивоваріння (BrewingLogs). Вона буде містити у собі такі атрибути: log_id (первинний ключ), brewing_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Brewings), status_code, message, log_time. 
Перевіримо таблицю BrewingLogs на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю обладнання пивоварів (BrewerBrewingEquipment). Вона буде містити у собі такі атрибути: brewer_equipment_id (первинний ключ), brewer_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Brewers), equipment_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею BrewingEquipment), connection_string, is_brewing.
Перевіримо таблицю BrewerBrewingEquipment на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю інгредієнтів пивоварів (BrewerIngredients). Вона буде містити у собі такі атрибути: brewer_ingredient_id (первинний ключ), brewer_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Brewers), ingredient_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Ingredients), weight.
Перевіримо таблицю BrewerIngredients на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю інгредієнтів у рецептах (RecipeIngredients). Вона буде містити у собі такі атрибути: recipe_ingredient_id (первинний ключ), recipe_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Recipes), ingredient_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Ingredients), weight. 
Перевіримо таблицю RecipeIngredients на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
За результатами проектування таблиць та зв’язків майбутньої бази даних, отримано її логічну схему (див. рис. 3.2).

 
Рисунок 3.2 – Логічна схема бази даних
 
Оскільки всі таблиці в наведеній логічній схемі бази даних знаходяться в третій нормальній формі, можна зробити висновок, що база даних загалом відповідає третій нормальній формі.
 
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


Користувачами розробленої системи є 2 типи акторів: клієнт та адміністратор. 
Основними потребами клієнта є: 
	можливість перегляду доступного обладнання, доступних інгредієнтів та рецептів, перегляд списку власного обладнання, створених рецептів, наявних у власності інгредієнтів;
	можливість додавання обладнання та інгредієнтів до свого інвентаря, створення, редагування та видалення власних рецептів та оцінення рецептів інших користувачів;
	можливість підключення до придбаного обладнання, отримання актуального статусу обраного обладнання, запуск процесу приготування обраного рецепту на обладнанні.
Основними потребами адміністратора є: 
	можливість перегляду, створення, редагування, видалення доступного обладнання та доступних інгредієнтів;
	можливість створення резервних копій даних системи та їхній імпорт в систему.
Взаємодію користувачів з серверною частиною системи представлено на діаграмі прецедентів (див. рис. 4.1).
 
 
Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи

Для розробки серверної частини системи було обрано мову програмування C# та використано технологію ASP.NET Core Web API. За систему управління базами даних обрано PostgreSQL, до якого з серверного застосунка здійснюється доступ за допомогою технології Entity Framework Core, яка надає зручний інтерфейс для взаємодії з базами даних у вигляді об’єктів сутностей.
Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).

 
Рисунок 4.2 – Діаграма розгортання серверної частини програмної системи
Для тестування та документування API використовується OpenApi (Swagger), що полегшує розробку та підвищує якість API. Використання захищеного протоколу HTTPS забезпечує безпеку даних під час їх передачі.
Розроблений серверний застосунок, побудований за концепціями Clean Architecture, складається із кількох шарів: Presentation, Application, Domain та Infrastructure. Кожен вищий рівень є залежним від попереднього.
Архітектура серверного застосунка представлена на діаграмі пакетів (див. рис. 4.3). 

 
Рисунок 4.3 – Діаграма пакетів серверної частини програмної системи

Для автоматизації мапування між об'єктами використовується бібліотека AutoMapper, що зменшує кількість дубльованого коду та спрощує розробку серверної частини.
Для реалізації автентифікації та авторизації використовується бібліотека .NET Identity, що забезпечує гнучкий та потужний механізм для керування доступом користувачів.

Приклади частин коду серверного застосунка наведені в додатку А. Таким чином, були визначені технології та архітектура серверної частини програмної системи.


4.2 Архітектура IoT частини


Користувачами IoT частини розробленої системи є 1 тип акторів - пивовар. Основними потребами пивовара є: можливість перевірки доступності пристрою; можливість підключення до пристрою; можливість отримання інформації про поточний стан пристрою; можливість запуску процесу пивоваріння на пристрої; можливість отримання статусу поточного процесу пивоваріння на пристрої; можливість переривання поточного процесу пивоваріння на пристрої; можливість отримати історію пивоварінь на обладнанні.  
Взаємодію користувача з IoT частиною системи представлено на діаграмі прецедентів (див. рис. 4.4).

 
Рисунок 4.4 – Діаграма прецедентів IoT частини програмної системи

IoT-пристрій розробленої системи після запуску видає посилання для підключення, яке необхідно вставити на вебсайті в налаштуваннях відповідного обладнання. Після цього, на сторінці обладнання можна надсилати запити на ІоТ пристрій.
Сам ІоТ пристрій працює в двох потоках:
	Перший потік моніторить стан пивоваріння та, якщо пивоваріння запущене, проводить його процес.
	Другий потік приймає запити від сервера і, відповідно до них, менеджить перший потік з процесом варіння або просто повертає певні дані (наприклад, стан обладнання на даний момент).
Під час розробки вбудованої частини системи було використано інструменти мови програмування C#. Також, для реалізації деяких аспектів системи використовувалися зовнішні технології, що підтримують мову програмування C#.
Для зчитування та безпечного збереження конфігураційних файлів було використано бібліотеку Newtonsoft.Json, яка надає зручні інструменти для роботи з форматом JSON.

 
Рисунок 4.5 – Діаграма пакетів IoT частини програмної системи

Результатом роботи став застосунок для вбудованих систем, що може бути запущений на широкому спектрі пристроїв.
Під час запуску додатку, спершу відбувається його ініціалізація та підготовка. Для визначення першочергових параметрів системи, користувачу надається url пристрою, який він потім повинен вказати в налаштуваннях обладнання на сайті. У конфігурації визначається кінцева точка входу серверної частини системи, модель контролера.
Система типів застосунку повністю повторює систему типів серверної частини і не зазнала змін.
Після успішної ініціалізації та підготовки об’єктів необхідних структур, система запускає два окремих потоки, один з яких буде відповідати за реагування на запити, що надходять з серверної частини, а інший — за контроль стану пивоваріння в обладнанні. 
Під час виконання потоку взаємодії з серверною частиною системи, програма отримує від серверної частини запити на вказані ендпоінти. Відповідно до вказаного ендпоінту програма змінює поточний стан пивоваріння, створюючи новий процес, зупиняючи існуючий або отримуючи актуальну інформацію про останнє пивоваріння чи загальний стан обладнання.
Під час виконання потоку взаємодії з пристроями, програма спостерігає за станом поточного процесу пивоваріння, і, якщо його запущено, періодично оновлює його, додаючи нові логи (про заповнення обладнання, про сам процес пивоваріння). 
На основі описаної взаємодії пристрою с користувачем було побудовано діаграму взаємодії (див. рис. 4.6).

 
Рисунок 4.6 – Діаграма взаємодії IoT частини програмної системи

При розробці системи було прийнято рішення використовувати архітектурну модель, яка поєднує принципи монолітної та модульної архітектур, щоб досягти балансу між простотою та розширюваністю. Це дозволяє їй ефективно працювати, навіть при невеликому збільшенні її складності, а також легко розширюватися за рахунок підтримки нових пристроїв без значних змін у внутрішньому коді.
Важливим аспектом є мінімізація використання постійної пам'яті для забезпечення високої продуктивності системи та зниження вимог до пристрою, на якому буде виконано систему. 
На основі описаної діяльності пристрою було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. рис. 4.7).

 
Рисунок 4.7 – Діаграма діяльності IoT частини програмної системи

Таким чином, за допомогою діаграм пакетів, станів та діяльності були визначені основні технології та архітектура системи. Приклади коду IoT-частини системи наведено в додатку Б.1


4.3 Архітектура клієнтської частини


В розробленій програмній системі можна виділити два типи акторів: адміністратора та пивовара.
До потреб пивовара відносяться: можливість перегляду та редагування інформації про власний профіль; можливість перегляду доступного обладнання для пивоваріння, інгредієнтів та рецептів; можливість запуску процесу пивоваріння обраного рецепта на обраному обладнанні; можливість отримання актуальної інформації про стан обладнання; можливість отримання актуальної інформації про стан пивоваріння на обладнанні;  можливість отримання інформації про власні пивоваріння; можливість додавання до свого інвентаря інгредієнтів та обладнання; можливість створення, редагування та видалення власних рецептів; можливість скасування пивоваріння; можливість оновлення додаткових послуг для поїздки.
Основними потребами адміністратора є: можливість створення, редагування, видалення рецептів, обладнання, інгредієнтів; можливість створення резервних копій даних системи та їхній імпорт в систему.
Взаємодію кожної ролі користувачів з клієнтською частиною системи представлено на діаграмі прецедентів (див. рис. 4.8).

 
Рисунок 4.8 – Діаграма прецедентів клієнтської частини програмної системи

Для створення клієнської частини програмної системи було обрано мову програмування TypeScript у поєднанні з React для забезпечення швидкості розробки та зручності використання завдяки статичній типізації та компонентному підходу. 
SCSS використовувався для стилізації елементів інтерфейсу, спрощуючи процес написання стилів. 
Для розробки інтерфейсу використано Material UI, що містить готові та стилізовані компоненти, що дозволяє швидко створювати привабливий веб-інтерфейс. 
Для навігації по сайту використано react-router-dom, що надає потужні засоби для створення реактивної навігації. 
Для виконання асинхронних запитів використано axios, який дозволяє зручно взаємодіяти з HTTP-запитами та обробляти відповіді сервера. 
Щодо локалізації, використано бібліотеку i18next для ефективного впровадження багатомовного інтерфейсу та зручного перекладу текстів.
Для розгортання веб-додатку використано Webpack, що забезпечує ефективний спосіб розгортання та автоматичне оновлення в реальному часі. Для візуалізації використаних пакетів було розроблено діаграму пакетів.
Для візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.9).

 
Рисунок 4.9 – Діаграма пакетів клієнтської частини програмної системи

Клієнтська частина проєкту організована згідно з принципом Feature-Sliced, що передбачає розділення застосунку на різні шари - каталоги верхнього рівня. У проєкті визначено 7 шарів: assets, components, config, pages, services, types, app [5].
Шар assets: Тут містяться ресурси проєкту, такі як зображення, шрифти та інші важливі файли для візуального оформлення, включно із файлами локалізації.
Шар components: Цей шар містить компоненти інтерфейсу, які можуть бути перевикористані в різних частинах проєкту. Він поділений на підкаталоги, такі як Button та layout з різними компонентами, наприклад, Header, MainTables, Modals та OwnTables.
Шар config: В цьому шарі знаходяться файли конфігурації. Наприклад, налаштування локалізації.
Шар pages: Тут знаходяться сторінки веб-сайту, які поділені на підкаталоги за їхньою функціональністю. Наприклад, каталог Auth містить сторінки для автентифікації, такі як Login та Register, тоді як сторінка Home відповідає за домашню сторінку.
Шар services: Цей шар містить файли, які відповідають за взаємодію з сервером. Наприклад, каталог api містить модулі для виконання HTTP-запитів, а authApi - модулі для автентифікації користувача.
Шар types: Тут розміщені файли, що визначають типи даних та інтерфейси, які використовуються в проєкті. Наприклад, каталог interfaces містить описи моделей даних, а types - додаткові типи для використання в коді.
Шар app: Цей шар визначає основну конфігурацію застосунку, включаючи вихідну точку додатку та його головний компонент App.js.
Для більш детальної візуалізації архітектури системи було розроблено діаграму компонентів (див. рис. 4.10).

 
Рисунок 4.10 – Діаграма компонентів клієнтської частини програмної системи

Використання програмної системи починається з авторизації – або створення нового акаунту, або входу в уже створений. При цьому, створити акаунт адміністратора неможливо.
В залежності від вказаної в базі даних ролі, користувач отримує доступ до функціоналу адміністратора або пивовара.
Як пивовар, так і адміністратор бачать на головній сторінці таблицю із даними обраного типу (рецепти, обладнання та інгредієнти) та кнопками перемикання обраного типу. Адміністратор додатково має функціонал для додавання нових даних до бази даних та експорту даних програмної системи.
З головної сторінки користувач може перейти до власного профілю та змінити інформацію про себе, встановивши нові прізвище та ім’я. Також на цій сторінці відображається інвентар користувача із його обладнанням, інгредієнтами у власності та створеними рецептами. Звідси користувач може перейти до менедменту процесів пивоваріння або змінювати інформацію про свої рецепти, додаючи нові або оновлюючи та видаляючи вже створені.
При переході на сторінку менеджменту процесів пивоваріння, користувач може отримувати інформацію про поточну доступність системи, стан обладнання, поточний стан процесу пивоваріння та історію пивоварінь. Тут користувач також може запустити новий процес пивоваріння або припинити поточний. 
Загалом адміністратор має доступ до того ж функціоналу, що й звичайний пивовар, окрім доступу до редагування інформації про обладнання та інгредієнти в системі, можливість редагування або видалення чужих рецептів та експорт даних.
Для детальнішої візуалізації взаємодії користувачів з клієнтською частиною системи розроблено діаграму взаємодії (див. рис. 4.11).

 
Рисунок 4.11 – Діаграма взаємодії клієнтської частини програмної системи

Приклади коду клієнтської частини системи наведено в додатку В. 
Це дозволило визначити основні технології та архітектуру системи через діаграми пакетів, компонентів та їх взаємодію. 
 
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження

Для запуску програми потрібно завантажити архів з програмою та розпакувати його. Оскільки програмний продукт використовує з'єднання з СУБД PostgreSQL, необхідно встановити її останню версію з офіційного сайту.
Для налаштування з'єднання програми з базою даних, необхідно cтворити файл appsettings.json за шляхом "apz-pzpi-21-2-teliuk-illia/Task2/apz-pzpi-21-2-teliuk-illia-task2/Heizenbrew". Та вказати в ньому інформацію за прикладом, наведеним в appsettings.Example.json. 
На рисунку 5.1 представлено орієнтовний вміст файлу appsettings.json. В місці, виділеному червоним, треба вказати інформацію для входу до бази даних. В місці, виділеному зеленим, необхідно вказати секретний ключ, що використовуватиметься при підписі токенів-авторизації. В місці, виділеному жовтим, слід вставити інформацію для створення в базі даних користувача із роллю «Адміністратор».
Необхідно змінити вміст рядка, виділеного червоним на рисунку 5.1, відповідно до інформації для входу до бази даних, яка встановлена на комп'ютері.

 
Рисунок 5.1 – Налаштування системи у файлі appsettings.json

Для налаштування з'єднання клієнтської частини з серверною необхідно cтворити файл .env за шляхом "apz-pzpi-21-2-teliuk-illia/Task4/apz-pzpi-21-2-teliuk-illia-task4" та вказати в ньому інформацію про посилання на сервер за прикладом, наведеним на рисунку 5.2. На місці, виділеному червоним, треба вказати посилання на хост серверної частини.

 
Рисунок 5.2 – Налаштування рядка підключення до серверної частини у файлі .env

Наступним кроком потрібно запустити серверну та клієнтську частини системи. Для запуску серверної частини можна використовувати Visual Studio, попередньо завантаживши це середовище розробки з офіційного сайту розробника. Після відкриття Heisenbrew.sln у папці «apz-pzpi-21-2-teliuk-illia/Task2» необхідно натиснути комбінацію клавіш «Ctrl + F5», аби запустити проєкт серверної частини. 
Для запуску клієнтської частини необхідно відкрити папку «apz-pzpi-21-2-teliuk-illia/Task4» у будь-якому доречному середовищі розробки. Можна завантажити Visual Studio Code та відкрити папку, використовуючи це IDE. Після цього необхідно написати «npm i» в інтегрованому терміналі, аби в проєкті було автоматично встановлено всі залежності, вказані в package.json. Тепер достатньо лише написати «npm run start» в тому ж інтегрованому терміналі та дочекатися запуску проєкту.
Запуск ІоТ-частини відбувається за тим же ж алгоритмом, що й запуск серверної частини. Для початку необхідно cтворити файл appsettings.json за шляхом "apz-pzpi-21-2-teliuk-illia/Task3/apz-pzpi-21-2-teliuk-illia-task3/Heizenbrew-iot". Та вказати в ньому інформацію за прикладом, наведеним в appsettings.Example.json. На рисунку 5.3 представлено орієнтовний вміст файлу appsettings.json. В місці, виділеному червоним, треба вказати налаштування ІоТ-пристрою, серед яких вказано початкову затримку, затримку на обробку 100 грам інгредієнта, базову затримку пивоваріння та пароль пристрою.
Необхідно змінити вміст рядків, виділених червоним на рисунку 5.3, відповідно до інформації для налаштувань системи пристрою.

 
Рисунок 5.3 – Встановлення налаштувань ІоТ-пристрою у файлі appsettings.json


5.2 Призначення і логічна структура


Функції, які може виконувати програма, можна розбити на декілька модулів, а саме:
	авторизація та реєстрація;
	профіль;
	обладнання;
	інгредієнти;
	рецепти;
	пивоваріння;
	дані системи. 
Модуль «Авторизація та реєстрація» включає функціонал для входу в систему та реєстрації нових користувачів. Реєстрація дозволяє користувачу створити обліковий запис у базі даних, який можна буде надалі використовувати для доступу за допомогою логіну та пароля. За замовчуванням, для входу в акаунт адміністратора слід авторизуватися за допомогою даних, які вказано в файлі appsettings.json, що будуть використанні при створені міграцій та оновлені бази даних.
Модуль «Профіль» містить функціонал для отримання інформації про власний профіль та її оновлення. Користувач може оновлювати свої ім’я та прізвище, які будуть відображатися на сторінці профілю користувача та в таблиці рецептів, демонструючи повне ім’я автора цього рецепта.
Модуль «Обладнання» містить функціонал для перегляду, додавання, оновлення, видалення обладнання, а також для додавання цього обладнання собі в інвентар, перегляду поточного статусу обладнання та запуску процесів пивоваріння на власному обладнанні.
Модуль «Інгредієнти» містить функціонал для перегляду, додавання, оновлення, видалення інгредієнтів, а також для додавання обраного інгредієнта собі в інвентар.
Модуль «Рецепти» містить функціонал для перегляду, додавання, оновлення, видалення рецептів, а також для запуску процесу пивоваріння обраного рецепта на власному обладнанні.
Модуль «Пивоваріння» містить функціонал для перегляду, запуску та припинення процесу пивоваріння.
Доступний лише адміністратору модуль «Дані системи» надає можливості експорту та імпорту даних.


5.3 Опис програмної реалізації


При запуску клієнтського застосунку відкривається головна сторінка (див. рис. 5.4). Неавторизованому користувачу доступні до перегляду таблиці зі списками наявних рецептів, обладнання та інгредієнтів. 
 
Рисунок 5.4 – Головна сторінка сайту

Для доступу до дій над цими даними спочатку треба авторизуватися, про що буде написано в стовпчику «Actions/Дії/Aktionen»
З цієї сторінки можна перейти до сторінки входу або реєстрації в систему, натиснувши відповідні кнопки в правому верхньому куті. На сторінці авторизації (див. рис. 5.5) необхідно або увійти в уже існуючий акаунт, або перейти на сторінку створення нового облікового запису (див. рис. 5.6).

 
Рисунок 5.5 – Сторінка авторизації
При вході в обліковий запис треба увести електронну пошту та пароль користувача.

 
Рисунок 5.6 – Сторінка реєстрації

При створенні нового облікового запису треба увести електронну пошту та пароль користувача і підтвердити пароль в додатковому полі і натиснути на кнопку реєстрації.
Також на будь-якій сторінці можна налаштувати мовні параметри сайту, натиснувши на іконку локалізації у правому верхньому куті (див. рис. 5.7). Доступні мови: українська, німецька та англійська. 

 
 
Рисунок 5.7 – Процес перемикання локалізації

Після успішної авторизації користувач отримує доступ до сторінки «Мій профіль» та «Керування варінням». Розглянемо користувацьку сторінку профілю (див. рис. 5.8). 

 
Рисунок 5.8 – Сторінка профілю користувача

На цій сторінці користувач може переглянути та відредагувати інформацію про себе а також переглянути список наявних у себе в інвентарі обладнання, інгредієтів та рецептів. Тут же ж можна створити новий рецепт (див. рис. 5.9) або перейти на сторінку управління варінням на обладнанні, натиснувши на відповідну кнопку (див. рис. 5.10).

 
 
 
Рисунок 5.9 – Створення нового рецепта
 
Рисунок 5.10 – Сторінка управління пивоварінням на обладнанні

На цій сторінці треба під’єднатися до ІоТ-пристрою. Оскільки наразі не вказано рядка з’єднання, клієнтська частина не може отримати дані про пристрій, запустити процеси пивоваріння на ньому та відслідковувати інформацію про статус всередині обладнання. Для цього слід запустити свій пристрій, авторизуватися в ньому та отримати рядок підключення (див. рис. 5.11).

 
Рисунок 5.11 – Запуск ІоТ пристрою та отримання рядка підключення

Після цього слід вставити рядок підключення в необхідне поле на сторінці керування варінням (див. рис. 5.12). Тепер нам відображається поточний стан варіння в обладнанні та статус всередині нього.

 
Рисунок 5.12 – Перегляд даних про обладнання після підключення до нього

Тепер слід обрати рецепт для приготування і натиснути на кнопку «Почати варіння» (див. рис. 5.13). 

 
Рисунок 5.13 – Вибір рецепта для приготування

Після запуску процесу пивоваріння його стан можна зручно відслідковувати на панелях «Поточний статус пивоваріння» та «Історія пивоварінь» (див. рис. 5.14).  Протягом цього процесу на панелях оновлюватиметься поточний статус пивоваріння та додаватимуться логи із інформацією про всі пройдені етапи. При цьому можна дочекатися завершення процесу пивоваріння або перервати його.

 
Рисунок 5.14 – Спостереження за процесом пивоваріння

Повернемося на головну сторінку. Тепер у пункті «Дії» наявні кнопки для взаємодії з даними. Звичайний користувач може додавати собі в профіль обране обладнання або інгредієнти (див. рис. 5.15). 

 
Рисунок 5.15 – Вигляд головної сторінки для авторизованого пивовара
Адміністратору ж надано розширений функціонал із можливістю додавати, оновлювати та видаляти обладнання чи інгредієнти (див. рис. 5.16)

 
Рисунок 5.16 – Вигляд головної сторінки для авторизованого адміністратора

На цій же ж сторінці адміністратор має можливість експортувати дані системи в форматі .xlsx (див. рис. 5.17)

 
Рисунок 5.17 – Експорт даних програмної системи
 
З цієї ж сторінки, натиснувши на назву обладнання, можна перейти на сторінку із повною інформацією про це обладнання (див. рис. 5.18).

 
Рисунок 5.18 – Сторінка інформації про обладнання

Так само можна перейти на сторінку обраного рецепту і переглянути список інгредієнтів в ньому та загальну ціну приготування, що розраховується відповідно до цього списку та ваги кожного інгредієнта (див. рис. 5.19).

 
Рисунок 5.19 – Сторінка інформації про рецепт

Таким чином, було описано, як користувач може взаємодіяти з розробленою програмною системою. Запис результатів функціонального тестування доступний за посиланням: https://youtu.be/hiYkYjWGZ8g (дата звернення: 14.06.2024)
ВИСНОВКИ


У результаті виконаної роботи була створена програмна система для предметної області «Автоматизація крафтового пивоваріння».
В процесі розробки було проведено аналіз предметної області, спроектовано структуру бази даних, розроблено архітектуру серверної, IoT та клієнтської частин програмної системи, а також реалізовано ці компоненти за допомогою технологій ASP.NET Core та React.js.
Розроблена програмна система дозволяє пивоварам зручно автоматизувати процес пивоваріння. Вона забезпечує реєстрацію та авторизацію користувачів, а також керування процесом пивоваріння. Користувачі можуть оновлювати інформацію про себе та ділитися рецептами, повністю контролювати процес пивоваріння через ІоТ-пристрій, зберігати історію пивоваріння та замовляти додаткове обладнання і матеріали.
Система автоматично вимірює та відстежує температуру сусла, вологість повітря, тиск в танках дображування та рівень рідини в ємностях. Користувачі отримують зручний доступ до процесу пивоваріння з різних пристроїв, можуть відстежувати процес у реальному часі та будь-де із можливістю припинення процесу в будь-який зручний їм час.
Адміністрування системи включає можливості оновлення асортименту обладнання та інгредієнтів, налаштування доступу до рецептів та даних, експорт та імпорт даних програмної системи, а також налаштування параметрів датчиків. Система підтримує українську, німецьку та англійську мови, а також може бути налаштована на інші мови за запитом.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1.	Бондарєв В.М. Об'єктно-орієнтоване програмування на С #. Навчальний посібник / В. М. Бондарєв. - Харків: СМІТ, 2009р. - 221 с. (дата звернення: 20.05.2024).
2. PostgreSQL 16.3 Documentation. PostgreSQL Documentation. URL: https://www.postgresql.org/docs/ (дата звернення: 20.05.2024).
3. ASP.NET documentation. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/dotnet/ (дата звернення: 20.05.2024).
4. React Reference Overview – React. URL: https://react.dev/ (дата звернення: 20.05.2024).
5. Feature-Sliced Design– Architectural methodology for frontend projects. URL: https://feature-sliced.design/ (дата звернення: 25.05.2024).
6.	 Stack overflow – Режим доступу до ресурсу: https://stackoverflow.com (дата звернення: 23.05.2024).















ДОДАТОК А
Результат перевірки на плагіат

 
Рисунок А.1– Результат перевірки на плагіат


 
ДОДАТОК Б
Програмний код серверної частини
Б.1 Код основного файлу для роботи сервера Program.cs


1 using DAL;
2 using heisenbrew_api.BuildExtensions;
3 using Serilog;
4 
5 Log.Logger = new LoggerConfiguration()
6     .MinimumLevel.Information()
7     .WriteTo.Console()
8     .WriteTo.File("logs/logDay-.txt", rollingInterval: RollingInterval.Day)
9     .CreateLogger();
10 
11 try
12 {
13     Log.Information("------------------------------------------------------");
14     Log.Information("------------------------------------------------------");
15     Log.Information("Starting web application");
16 
17     var builder = WebApplication.CreateBuilder(args);
18 
19     builder.Host.UseSerilog();
20 
21 
22 
23 
24 
25 
26     builder.Services.AddControllers();
27     builder.Services.AddSwaggerGen();
28     builder.Services.AddEndpointsApiExplorer();
29     builder.Services.AddSetSwagger();
30     builder.Services.AddHttpContextAccessor();
31     builder.Services.AddServices();
32     builder.Services.AddSetSecurity(builder.Configuration);
33     builder.Services.AddSetCors();
34     builder.Services.AddSwaggerGen();
35     builder.Services.AddAutoMapper(typeof(Program).Assembly);
36     builder.Services.AddDbSetup(builder.Configuration);
37 
38 
39 
40 
41     // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
42 
43     var app = builder.Build();
44     // Configure the HTTP request pipeline.
45     if (app.Environment.IsDevelopment())
46     {
47         app.UseSwagger();
48         app.UseSwaggerUI();
49     }
50 
51     app.UseHttpsRedirection();
52     app.UseCors(CorsInjection.PolicyName);
53 
54     app.UseAuthentication();
55     app.UseAuthorization();
56 
57     app.MapControllers();
58 
59     app.Run();
60 }
61 catch (Exception ex)
62 {
63     Log.Fatal(ex, "Application terminated unexpectedly");
64 }
65 finally
66 {
67     Log.CloseAndFlush();
68 }


Б.2 Код контролера для роботи з обладнанням


1 using BLL.EquipmentManagement;
2 using Core;
3 using Infrustructure.Dto.Equipment;
4 using Microsoft.AspNetCore.Authorization;
5 using Microsoft.AspNetCore.Mvc;
6 
7 namespace heisenbrew_api.Controllers
8 {
9     [Route("api/[controller]")]
10     [ApiController]
11     public class EquipmentController : ControllerBase
12     {
13         private readonly IEquipmentService _equipmentService;
14 
15         public EquipmentController(IEquipmentService equipmentService)
16         {
17             _equipmentService = equipmentService;
18         }
19 
20         /// <summary>
21         /// Creates new brewing equipment.
22         /// </summary>
23         /// <param name="createBrewingEquipmentDto">The dto to create the equipment.</param>
24         /// <remarks>
25         /// If the operation is successful, it will return a corresponding message.
26         /// </remarks>
27         /// <returns>An IActionResult representing the result of the operation.</returns>
28         [Authorize(Roles = nameof(Roles.Administrator))]
29         [HttpPost("create")]
30         public async Task<IActionResult> CreateBrewingEquipment([FromBody] CreateBrewingEquipmentDto createBrewingEquipmentDto)
31         {
32             var result = await _equipmentService.AddEquipmentAsync(createBrewingEquipmentDto);
33             return this.CreateResponse(result);
34         }
35 
36         /// <summary>
37         /// Updates an existing brewing equipment.
38         /// </summary>
39         /// <param name="updateEquipmentDto">The dto to update the equipment.</param>
40         /// <remarks>
41         /// If the operation is successful, it will return a corresponding message.
42         /// </remarks>
43         /// <returns>An IActionResult representing the result of the operation.</returns>
44         [Authorize(Roles = nameof(Roles.Administrator))]
45         [HttpPut("update")]
46         public async Task<IActionResult> UpdateBrewingEquipment([FromBody] UpdateBrewingEquipmentDto updateEquipmentDto)
47         {
48             var result = await _equipmentService.UpdateEquipmentAsync(updateEquipmentDto);
49             return this.CreateResponse(result);
50         }
51 
52         /// <summary>
53         /// Deletes an existing brewing equipment.
54         /// </summary>
55         /// <param name="id">The id of the equipment which should be deleted.</param>
56         /// <remarks>
57         /// If the operation is successful, it will return a corresponding message.
58         /// </remarks>
59         /// <returns>An IActionResult representing the result of the operation.</returns>
60         [Authorize(Roles = nameof(Roles.Administrator))]
61         [HttpDelete("delete/{id}")]
62         public async Task<IActionResult> DeleteBrewingEquipment(Guid id)
63         {
64             var result = await _equipmentService.DeleteEquipmentAsync(id);
65             return this.CreateResponse(result);
66         }
67 
68         /// <summary>
69         /// Gets list of brewering equipment.
70         /// </summary>
71         /// <remarks>
72         /// If the operation is successful, it will return a corresponding message.
73         /// </remarks>
74         /// <returns>An IActionResult representing the result of the operation.</returns>
75         [HttpGet]
76         public async Task<IActionResult> GetAllEquipment()
77         {
78             var result = await _equipmentService.GetAllEquipmentAsync();
79             return this.CreateResponse(result);
80         }
81 
82         /// <summary>
83         /// Gets equipment by id.
84         /// </summary>
85         /// <param name="id">The id of the equipment.</param>
86         /// <remarks>
87         /// If the operation is successful, it will return a corresponding message.
88         /// </remarks>
89         /// <returns>An IActionResult representing the result of the operation.</returns>
90         [HttpGet("{id}")]
91         public async Task<IActionResult> GetEquipmentById(Guid id)
92         {
93             var result = await _equipmentService.GetBrewingEquipmentByIdAsync(id);
94             return this.CreateResponse(result);
95         }
96 
97         /// <summary>
98         /// Gets list of brewer's equipment.
99         /// </summary>
100         /// <remarks>
101         /// If the operation is successful, it will return a corresponding message.
102         /// </remarks>
103         /// <returns>An IActionResult representing the result of the operation.</returns>
104         [Authorize]
105         [HttpGet("my-equipment")]
106         public async Task<IActionResult> GetBrewerEquipment()
107         {
108             var result = await _equipmentService.GetBrewerEquipmentAsync();
109             return this.CreateResponse(result);
110         }
111 
112         /// <summary>
113         /// Gets equipment from brewer's inventory by id.
114         /// </summary>
115         /// <param name="id">The id of the equipment.</param>
116         /// <remarks>
117         /// If the operation is successful, it will return a corresponding message.
118         /// </remarks>
119         /// <returns>An IActionResult representing the result of the operation.</returns>
120         [Authorize]
121         [HttpGet("my-equipment/{id}")]
122         public async Task<IActionResult> GetBrewerEquipmentById(Guid id)
123         {
124             var result = await _equipmentService.GetBrewerEquipmentByIdAsync(id);
125             return this.CreateResponse(result);
126         }
127 
128 
129         /// <summary>
130         /// Adds equipment to brewer's inventory.
131         /// </summary>
132         /// <param name="id">The id of the equipment to be bought.</param>
133         /// <remarks>
134         /// If the operation is successful, it will return a corresponding message.
135         /// </remarks>
136         /// <returns>An IActionResult representing the result of the operation.</returns>
137         [Authorize]
138         [HttpGet("my-equipment/buy/{id}")]
139         public async Task<IActionResult> BuyEquipment(Guid id)
140         {
141             var result = await _equipmentService.BuyBrewingEquipmentAsync(id);
142             return this.CreateResponse(result);
143         }
144 
145         /// <summary>
146         /// Update equipment's connection string.
147         /// </summary>
148         /// <param name="id">The id of the equipment to update its connection string.</param>
149         /// <param name="connectionString">The new connection string.</param>
150         /// <remarks>
151         /// If the operation is successful, it will return a corresponding message.
152         /// </remarks>
153         /// <returns>An IActionResult representing the result of the operation.</returns>
154         [Authorize]
155         [HttpGet("my-equipment/update-string/{id}/{connectionString}")]
156         public async Task<IActionResult> UpdateConnectionString(Guid id, string connectionString)
157         {
158             var result = await _equipmentService.UpdateConnectionStringAsync(id, connectionString);
159             return this.CreateResponse(result);
160         }
161 
162         /// <summary>
163         /// Gets an equipment's status.
164         /// </summary>
165         /// <param name="equipmentId">The id of the equipment to get its status.</param>
166         /// <remarks>
167         /// If the operation is successful, it will return a corresponding message.
168         /// </remarks>
169         /// <returns>An IActionResult representing the result of the operation.</returns>
170         [Authorize]
171         [HttpGet("status/{equipmentId}")]
172         public async Task<IActionResult> GetEquipmentStatus(Guid equipmentId)
173         {
174             var result = await _equipmentService.GetEquipmentStatusAsync(equipmentId);
175             return this.CreateResponse(result);
176         }
177 
178     }
179 }


Б.3 Код сервісу для роботи із профілем користувача


1 using AutoMapper;
2 using Core;
3 using DAL;
4 using Infrustructure.Dto.UserProfile;
5 using Infrustructure.ErrorHandling.Errors.Base;
6 using Infrustructure.ErrorHandling.Errors.ServiceErrors;
7 using Infrustructure.Extensions;
8 using Microsoft.AspNetCore.Http;
9 using Microsoft.EntityFrameworkCore;
10 using Microsoft.Extensions.Logging;
11 using BLL.ProfileManagement.Interface;
12 
13 namespace BLL.ProfileManagement
14 {
15     public class ProfileService : IProfileService
16     {
17         private readonly ILogger<ProfileService> _logger;
18         private readonly IMapper _mapper;
19         private readonly ApplicationDbContext _context;
20         private readonly IHttpContextAccessor _contextAccessor;
21 
22 
23         public ProfileService(ILogger<ProfileService> logger, IMapper mapper, ApplicationDbContext context, IHttpContextAccessor contextAccessor)
24         {
25             _logger = logger;
26             _mapper = mapper;
27             _context = context;
28             _contextAccessor = contextAccessor;
29         }
30 
31         public async Task<Result<BrewerProfileDto, Error>> GetBrewerProfileAsync(Guid brewerId)
32         {
33             try
34             {
35                 var brewer = await _context
36                     .Brewers
37                     .FirstOrDefaultAsync(x => x.Id == brewerId);
38 
39                 if (brewer is null)
40                 {
41                     return ProfileServiceErrors.UserNotFoundError;
42                 }
43 
44                 return _mapper.Map<BrewerProfileDto>(brewer);
45             }
46             catch (Exception ex)
47             {
48                 _logger.LogError($"BLL.GetBrewerProfileAsync ERROR: {ex.Message}");
49 
50                 return ProfileServiceErrors.GetBrewerProfileError;
51             }
52         }
53 
54         public async Task<Result<BrewerProfileDto, Error>> GetOwnBrewerProfileAsync()
55         {
56             try
57             {
58                 var isIdValid = _contextAccessor.TryGetUserId(out Guid userId);
59 
60                 if (isIdValid is false)
61                 {
62                     return UserErrors.InvalidUserId;
63                 }
64 
65                 var brewer = await _context
66                     .Brewers
67                     .FirstOrDefaultAsync(x => x.Id == userId);
68 
69                 if (brewer is null)
70                 {
71                     return ProfileServiceErrors.UserNotFoundError;
72                 }
73 
74                 return _mapper.Map<BrewerProfileDto>(brewer);
75             }
76             catch (Exception ex)
77             {
78                 _logger.LogError($"BLL.GetOwnBrewerProfileAsync ERROR: {ex.Message}");
79 
80                 return ProfileServiceErrors.GetBrewerProfileError;
81             }
82         }
83 
84         public async Task<Result<BrewerProfileDto, Error>> UpdateBrewerProfileAsync(UpdateBrewerProfileDto brewerProfileDto)
85         {
86             try
87             {
88                 var isIdValid = _contextAccessor.TryGetUserId(out Guid userId);
89 
90                 if (isIdValid is false)
91                 {
92                     return UserErrors.InvalidUserId;
93                 }
94 
95                 var brewer = await _context
96                     .Brewers
97                     .FirstOrDefaultAsync(x => x.Id == userId);
98 
99                 if (brewer is null)
100                 {
101                     return ProfileServiceErrors.UserNotFoundError;
102                 }
103 
104                 _mapper.Map(brewerProfileDto, brewer);
105                 await _context.SaveChangesAsync();
106 
107                 return _mapper.Map<BrewerProfileDto>(brewer);
108             }
109             catch (Exception ex)
110             {
111                 _logger.LogError($"BLL.UpdateBrewerProfileAsync ERROR: {ex.Message}");
112 
113                 return ProfileServiceErrors.UpdateProfileError;
114             }
115         }
116     }
117 }



Б.4 Код методу для запуску процесу пивоваріння


1 public async Task<Result<string, Error>> StartBrewingAsync(Guid recipeId, Guid equipmentId)
2         {
3             try
4             {
5                 var isUserValid = _contextAccessor.TryGetUserId(out Guid userId);
6 
7                 if (!isUserValid)
8                 {
9                     return UserErrors.InvalidUserId;
10                 }
11 
12                 var user = await _context.Brewers.Include(u => u.Ingredients).FirstOrDefaultAsync(u => u.Id == userId);
13                 var equipment = await _context.BrewerBrewingEquipment.Include(bE => bE.BrewingEquipment).FirstOrDefaultAsync(bE => bE.Id == equipmentId);
14 
15                 if(equipment is null)
16                 {
17                     return BrewingEquipmentServiceErrors.GetEquipmentByIdError;
18                 }
19 
20                 if (equipment.BrewerId != userId)
21                 {
22                     return BrewingEquipmentServiceErrors.NotYourEquipmentError;
23                 }
24 
25 
26                 if (equipment.IsBrewing)
27                 {
28                     return BrewingServiceErrors.EquipmentIsBusyError;
29                 }
30 
31                 var recipe = await _context.Recipes.Include(r => r.Ingredients).ThenInclude(i => i.Ingredient).FirstOrDefaultAsync(r => r.Id == recipeId);
32 
33 
34                 foreach (var ingredient in recipe.Ingredients)
35                 {
36                     if (!user.Ingredients.Select(i => i.IngredientId).ToList().Contains(ingredient.IngredientId))
37                     {
38                         return BrewingServiceErrors.DontHaveIngredientError(ingredient.Ingredient.Name);
39                     }
40 
41                     var usersIngredient = user.Ingredients.FirstOrDefault(i => i.IngredientId == ingredient.IngredientId);
42 
43                     if (usersIngredient.Weight < ingredient.Weight)
44                     {
45                         return BrewingServiceErrors.DontHaveEnoughIngredientError(ingredient.Ingredient.Name);
46                     }
47 
48                     usersIngredient.Weight -= ingredient.Weight;
49                 }
50 
51                 var brewing = new Brewing { BrewerBrewingEquipmentId = equipmentId, RecipeId = recipeId, Status = Status.Started, BrewingLogs = new List<BrewingLog>(), CreatedAt = DateTime.Now};
52                 brewing.BrewingLogs.Add(new BrewingLog { Brewing = brewing, StatusCode = BrewingLogCode.Info, Message = "Starting the brewing process", LogTime = DateTime.Now});
53                 //IoT Logic
54 
55                 await _context.Brewings.AddAsync(brewing);
56                 equipment.IsBrewing = true;
57                 await _context.SaveChangesAsync();
58                 return $"Successfully started brewing the \"{recipe.Title}\" on your \"{equipment.BrewingEquipment.Name}\"!";
59             }
60             catch (Exception ex)
61             {
62                 _logger.LogError($"BLL.StartBrewingAsync ERROR: {ex.Message}");
63                 return BrewingServiceErrors.CreateBrewingError;
64             }
65         }

 
ДОДАТОК В
Програмний код IoT пристрою
В.1 Стартовий файл програми


1 using Heisenbrew_iot;
2 using System.Net;
3 using System.Net.Sockets;
4 using System.Text.Json;
5 
6 class Program
7 {
8     static int GetAvailablePort()
9     {
10         var listener = new TcpListener(IPAddress.Loopback, 0);
11         listener.Start();
12         var port = ((IPEndPoint)listener.LocalEndpoint).Port;
13         listener.Stop();
14         return port;
15     }
16 
17     static int CalculateIngredientTime(double weight)
18     {
19 
20         int timePer100Grams = config.GetValue<int>("AppSettings:DelayPer100Grams");
21         int addingTime = (int)(weight / 100) * timePer100Grams;
22 
23         return addingTime;
24     }
25 
26     static int CalculateBrewingTime(Recipe recipe)
27     {
28         double totalWeight = recipe.Ingredients.Sum(ingredient => ingredient.Weight);
29         int baseBrewingTime = config.GetValue<int>("AppSettings:BaseBrewingDelay");
30         baseBrewingTime += CalculateIngredientTime(totalWeight);
31 
32 
33         return baseBrewingTime;
34     }
35 
36 
37     static async Task Main(string[] args)
38     {
39         var appPassword = config.GetValue<string>("AppSettings:Password");
40 
41         while (true)
42         {
43             Console.Write("Enter the password of the equipment: ");
44             var password = Console.ReadLine();
45 
46             if (password == appPassword) break;
47 
48             Console.WriteLine("Wrong password, try again!\n");
49 
50         }
51 
52         var port = GetAvailablePort();
53 
54         var endpointThread = Task.Run(() => HandleEndpoints(port));
55         var brewingThread = Task.Run(() => ManageBrewing());
56 
57         await Task.WhenAll(endpointThread, brewingThread);
58     }
59 
60     static async Task HandleEndpoints(int port)
61     {
62         var listener = new HttpListener();
63         listener.Prefixes.Add($"http://localhost:{port}/");
64         listener.Start();
65         Console.WriteLine($"Server is running at http://localhost:{port}/");
66 
67         while (true)
68         {
69             var context = await listener.GetContextAsync();
70             _ = Task.Run(() => ProcessRequest(context));
71         }
72     }
73 
74     static async Task ManageBrewing()
75     {
76         var InitialDelay = config.GetValue<int>("AppSettings:DelayPer100Grams");
77 
78         while (true)
79         {
80             if (isBrewing && currentBrewing != null)
81             {
82                 currentBrewing.Status = Status.Started;
83                 lastUpdate = DateTime.Now;
84                 var startingMessage = $"Starting brewing the {currentBrewing.Recipe.Title}...";
85                 currentBrewing.BrewingLogs.Add(new BrewingLog { StatusCode = BrewingLogCode.Info, Message = startingMessage, LogTime = lastUpdate });
86                 Console.WriteLine($"Starting brewing for recipe: {currentBrewing.Recipe.Title}");
87                 await Task.Delay(InitialDelay);
88 
89                 if (isAborted)
90                 {
91                     isAborted = false;
92                     continue;
93                 }
94                 currentBrewing.Status = Status.Filling;
95                 foreach (var ingredient in currentBrewing.Recipe.Ingredients)
96                 {
97                     if (isAborted)
98                     {
99                         break;
100                     }
101 
102                     lastUpdate = DateTime.Now;
103                     var addingMessage = $"Adding {ingredient.Name}...";
104                     var ingredientDelay = CalculateIngredientTime(ingredient.Weight);
105                     currentBrewing.BrewingLogs.Add(new BrewingLog { StatusCode = BrewingLogCode.Info, Message = addingMessage, LogTime = lastUpdate });
106                     Console.WriteLine($"[{lastUpdate}] {BrewingLogCode.Info}: {addingMessage}");
107                     await Task.Delay(ingredientDelay);
108 
109                 }
110                 if (isAborted)
111                 {
112                     isAborted = false;
113                     continue;
114                 }
115                 currentBrewing.Status = Status.Processing;
116                 lastUpdate = DateTime.Now;
117                 var brewingMessage = "Brewing the beer...";
118                 currentBrewing.BrewingLogs.Add(new BrewingLog { StatusCode = BrewingLogCode.Info, Message = brewingMessage, LogTime = lastUpdate });
119                 Console.WriteLine($"[{lastUpdate}] {BrewingLogCode.Info}: {brewingMessage}");
120                 await Task.Delay(CalculateBrewingTime(currentBrewing.Recipe));
121                 if (isAborted)
122                 {
123                     isAborted = false;
124                     continue;
125                 }
126                 currentBrewing.Status = Status.Finished;
127                 lastUpdate = DateTime.Now;
128                 var completedMessage = "The brewing process is completed.";
129                 currentBrewing.BrewingLogs.Add(new BrewingLog { StatusCode = BrewingLogCode.Info, Message = completedMessage, LogTime = lastUpdate });
130 
131                 Console.WriteLine($"[{lastUpdate}] {BrewingLogCode.Info}: {completedMessage}");
132                 brewingsHistory.Add(currentBrewing);
133                 currentBrewing = null;
134                 isBrewing = false;
135 
136 
137 
138 
139             }
140             await Task.Delay(1000);
141         }
142     }
143 
144     static async Task ProcessRequest(HttpListenerContext context)
145     {
146         var request = context.Request;
147         var response = context.Response;
148 
149         string responseString = "";
150 
151         switch (request.Url.LocalPath)
152         {
153             case "/status":
154                 lastUpdate = DateTime.Now;
155                 var random = new Random();
156                 var statusDto = new EquipmentStatusDto
157                 {
158                     Temperature = random.NextDouble() * (40.0 - (-20.0)) - 20.0,
159                     Pressure = random.NextDouble() * (1100.0 - 900.0) + 900.0,
160                     Humidity = random.NextDouble() * (100.0 - 0.0),
161                     Fullness = random.NextDouble(),
162                     LastUpdate = lastUpdate.ToString(),
163                     IsBrewing = isBrewing
164                 };
165                 responseString = JsonSerializer.Serialize(statusDto);
166                 break;
167 
168             case "/startbrewing":
169                 if (!isBrewing)
170                 {
171                     using (var reader = new StreamReader(request.InputStream))
172                     {
173                         var requestBody = await reader.ReadToEndAsync();
174                         var recipe = JsonSerializer.Deserialize<Recipe>(requestBody);
175                         isBrewing = true;
176                         lastUpdate = DateTime.Now;
177                         currentBrewing = new Brewing
178                         {
179                             Id = Guid.NewGuid(),
180                             RecipeId = recipe.Id,
181                             Recipe = recipe,
182                             BrewingLogs = new List<BrewingLog>(),
183                             Status = Status.Started,
184                             CreatedAt = lastUpdate
185                         };
186 
187                         Console.WriteLine($"Aproximate brewing time: {CalculateBrewingTime(recipe)}");
188 
189                         var brewingDto = new BrewingFullInfoDto
190                         (
191                         currentBrewing.Id,
192                         currentBrewing.RecipeId,
193                         Enum.GetName(typeof(Status), currentBrewing.Status),
194                         currentBrewing.BrewingLogs.Select(b => b.LogTime).LastOrDefault().ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss"),
195                         currentBrewing.BrewingLogs.Select(bL => new BrewingLogDto(Enum.GetName(bL.StatusCode.GetType(), bL.StatusCode), bL.Message, bL.LogTime.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss"))).ToList(),
196                         currentBrewing.CreatedAt.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss")
197                         );
198                         responseString = JsonSerializer.Serialize(brewingDto);
199                     }
200                 }
201                 else
202                 {
203                     responseString = "Another brewing process is already in progress.";
204                 }
205                 break;
206 
207             case "/brewingstatus":
208                 lastUpdate = DateTime.Now;
209                 if (isBrewing && currentBrewing != null)
210                 {
211                     var brewingStatusDto = new BrewingFullInfoDto
212                     (
213                         currentBrewing.Id,
214                         currentBrewing.RecipeId,
215                         currentBrewing.Status.ToString(),
216                         currentBrewing.CreatedAt.ToString(),
217                         currentBrewing.BrewingLogs.Select(bL => new BrewingLogDto(Enum.GetName(bL.StatusCode.GetType(), bL.StatusCode), bL.Message, bL.LogTime.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss"))).ToList(),
218                         currentBrewing.CreatedAt.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss")
219                     );
220                     responseString = JsonSerializer.Serialize(brewingStatusDto);
221                 }
222                 else
223                 {
224                     var lastBrewing = brewingsHistory.Last();
225                     var brewingStatusDto = new BrewingFullInfoDto
226                     (
227                         lastBrewing.Id,
228                         lastBrewing.RecipeId,
229                         lastBrewing.Status.ToString(),
230                         lastBrewing.CreatedAt.ToString(),
231                         lastBrewing.BrewingLogs.Select(bL => new BrewingLogDto(Enum.GetName(bL.StatusCode.GetType(), bL.StatusCode), bL.Message, bL.LogTime.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss"))).ToList(),
232                         lastBrewing.CreatedAt.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss")
233                     );
234                     responseString = JsonSerializer.Serialize(brewingStatusDto);
235                 }
236                 break;
237 
238             case "/abort":
239                 if (isBrewing && currentBrewing != null)
240                 {
241                     currentBrewing.Status = Status.Aborted;
242                     var abortedMessage = "The brewing process was aborted.";
243                     currentBrewing.BrewingLogs.Add(new BrewingLog { StatusCode = BrewingLogCode.Info, Message = abortedMessage });
244 
245                     Console.WriteLine($"[{DateTime.Now}] {BrewingLogCode.Info}: {abortedMessage}");
246 
247                     brewingsHistory.Add(currentBrewing);
248                     currentBrewing = null;
249                     isBrewing = false;
250                     isAborted = true;
251                     lastUpdate = DateTime.Now;
252                     responseString = "Successfully aborted.";
253 
254                 }
255                 else
256                 {
257                     responseString = "No brewing process to abort.";
258                 }
259                 break;
260 
261             case "/history-count":
262                 lastUpdate = DateTime.Now;
263                 if (currentBrewing is not null)
264                 {
265                     responseString = (brewingsHistory.Count + 1).ToString();
266                 }
267                 else
268                 {
269                     responseString = brewingsHistory.Count.ToString();
270                 }
271 
272                 break;
273 
274             case "/is-reachable":
275                 lastUpdate = DateTime.Now;
276                 responseString = true.ToString();
277                 break;
278 
279             default:
280                 response.StatusCode = 404;
281                 responseString = "Endpoint not found.";
282                 break;
283         }
284 
285         byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString);
286         response.ContentLength64 = buffer.Length;
287         await response.OutputStream.WriteAsync(buffer, 0, buffer.Length);
288         response.Close();
289     }
290 
291     static IConfigurationRoot config = new ConfigurationBuilder()
292             .SetBasePath(Directory.GetCurrentDirectory())
293             .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
294             .Build();
295 
296     static bool isBrewing = false;
297     static bool isAborted = false;
298     static Brewing currentBrewing = null;
299     static DateTime lastUpdate = DateTime.Now;
300     static List<Brewing> brewingsHistory = new List<Brewing>();
301 
302 }
 
ДОДАТОК Г
Програмний код клієнтської частини
Г.1 Код сторінки профілю користувача


1 import React, { useEffect, useState } from "react";
2 import { Container, Typography, Paper, Box, Button } from "@mui/material";
3 import { useTranslation } from 'react-i18next';
4 
5 import EditProfileModal from "../components/layout/Modals/EditProfileModal";
6 import {
7     getOwnEquipment,
8     getOwnIngredients,
9     getOwnProfile,
10     getOwnRecipes,
11     updateProfile,
12 } from "../services/api";
13 import OwnBrewingEquipment, {
14     OwnBrewingEquipmentDto,
15 } from "../components/layout/OwnTables/OwnBrewingEquipment";
16 
17 import OwnIngredients, {
18     OwnIngredientsDto,
19 } from "../components/layout/OwnTables/OwnIngredients";
20 import OwnRecipes, {
21     OwnRecipeDto,
22 } from "../components/layout/OwnTables/OwnRecipes";
23 import { RecipeDto } from "./RecipeDetails";
24 
25 interface BrewerProfileDto {
26     id: string;
27     fullName: string;
28     profileColor: string;
29 }
30 
31 const ProfilePage: React.FC = () => {
32     const { t } = useTranslation();
33     const [profile, setProfile] = useState<BrewerProfileDto | null>(null);
34     const [equipment, setEquipment] = useState<OwnBrewingEquipmentDto[] | null>(
35         null,
36     );
37     const [ingredients, setIngredientss] = useState<OwnIngredientsDto[] | null>(
38         null,
39     );
40     const [recipes, setRecipes] = useState<RecipeDto[] | null>(null);
41     const [editModalOpen, setEditModalOpen] = useState(false);
42     const userRole = localStorage.getItem("userRole");
43     const isLogged = localStorage.getItem("bearer") !== null;
44     const userId = localStorage.getItem("userId");
45 
46     const fetchProfileData = async () => {
47         try {
48             const profileData =
49                 (await getOwnProfile()) as unknown as BrewerProfileDto;
50             setProfile(profileData);
51 
52             const equipmentData =
53                 (await getOwnEquipment()) as unknown as OwnBrewingEquipmentDto[];
54             setEquipment(equipmentData);
55 
56             const ingredientsData =
57                 (await getOwnIngredients()) as unknown as OwnIngredientsDto[];
58             setIngredientss(ingredientsData);
59 
60             const recipesData =
61                 (await getOwnRecipes()) as unknown as RecipeDto[];
62             setRecipes(recipesData);
63         } catch (error) {
64             console.error("Error fetching profile data:", error);
65         }
66     };
67 
68     const handleDataChange = () => {
69         fetchProfileData();
70     };
71 
72     useEffect(() => {
73         fetchProfileData();
74     }, []);
75 
76     if (!profile || !equipment || !ingredients || !recipes) {
77         return <Typography>{t("loading")}...</Typography>;
78     }
79 
80     const handleEditProfile = () => {
81         setEditModalOpen(true);
82     };
83 
84     const handleCloseEditModal = () => {
85         setEditModalOpen(false);
86     };
87 
88     const handleSaveProfile = async (firstName: string, lastName: string) => {
89         try {
90             await updateProfile(firstName, lastName);
91             const profileData =
92                 (await getOwnProfile()) as unknown as BrewerProfileDto;
93             setProfile(profileData);
94         } catch (error) {
95             console.error("Error saving profile:", error);
96         }
97     };
98 
99     return (
100         <Container style={{ marginTop: "15rem" }}>
101             <Paper sx={{ padding: 4, marginTop: 4 }}>
102                 <Typography variant="h2" gutterBottom>
103                     {t("profile")}:{" "}
104                     {profile.fullName !== " "
105                         ? profile.fullName
106                         : t("setName")}
107                 </Typography>
108                 <Button
109                     variant="outlined"
110                     color="primary"
111                     style={{ fontSize: "3rem" }}
112                     onClick={handleEditProfile}
113                 >
114                     {t("editProfile")}
115                 </Button>
116                 <Box sx={{ marginTop: 4 }}>
117                     <Typography variant="h2" gutterBottom>
118                         {t("equipment")}
119                     </Typography>
120                     <OwnBrewingEquipment data={equipment} />
121                 </Box>
122                 <Box sx={{ marginTop: 4 }}>
123                     <Typography variant="h2" gutterBottom>
124                         {t("ingredients")}
125                     </Typography>
126                     <OwnIngredients data={ingredients} />
127                 </Box>
128                 <Box sx={{ marginTop: 4 }}>
129                     <Typography variant="h2" gutterBottom>
130                         {t("recipes")}
131                     </Typography>
132                     <OwnRecipes
133                         data={recipes}
134                         onRecipesChange={handleDataChange}
135                     />
136                 </Box>
137             </Paper>
138             <EditProfileModal
139                 open={editModalOpen}
140                 onClose={handleCloseEditModal}
141                 onSave={handleSaveProfile}
142                 initialFirstName={profile.fullName.split(" ")[0]}
143                 initialLastName={profile.fullName.split(" ")[1]}
144             />
145         </Container>
146     );
147 };
148 
149 export default ProfilePage;


 
Г.2 Код сервісу для надсилання запитів на апі


1 import axios from "axios";
2 
3 const url = process.env.REACT_APP_SERVER_URL
4     ? process.env.REACT_APP_SERVER_URL
5     : "https://localhost:7084/api/";
6 
7 interface UpdateBrewerProfileDto {
8     firstName: string;
9     lastName: string;
10 }
11 
12 interface UpdateConnectionStringDto {
13     equipmentId: string;
14     connectionString: string;
15 }
16 
17 interface UpdateEquipmentDto {
18     id: string;
19     name: string;
20     description: string;
21     price: number;
22 }
23 
24 interface CreateEquipmentDto {
25     name: string;
26     description: string;
27     price: number;
28 }
29 
30 interface UpdateRecipeDto {
31     id: string;
32     title: string;
33     description: string;
34     ingredients: CreateRecipeIngredientDto[];
35 }
36 
37 interface CreateRecipeDto {
38     title: string;
39     description: string;
40     ingredients: CreateRecipeIngredientDto[];
41 }
42 
43 interface CreateRecipeIngredientDto {
44     id: string;
45     weight: number;
46 }
47 
48 interface CreateIngredientDto {
49     name: string;
50     price: number;
51 }
52 
53 interface UpdateIngredientDto {
54     id: string;
55     name: string;
56     price: number;
57 }
58 
59 interface BuyIngredientDto {
60     ingredientId: string;
61     weight: number;
62 }
63 
64 export const getItemsList = async (type: string) =>
65     await axios.get(`https://localhost:7084/api/${type}`);
66 
67 export const getEquipmentDetails = async (equipmentId: string) =>
68     await axios.get(`${url}Equipment/${equipmentId}`);
69 
70 export const getRecipeDetails = async (recipeId: string) =>
71     await axios.get(`${url}Recipe/${recipeId}`);
72 
73 export const getOwnProfile = async () => {
74     const bearer = localStorage.getItem("bearer");
75     const { data } = await axios.get<string>(`${url}Profile/me`, {
76         headers: { Authorization: `Bearer ${bearer}` },
77     });
78 
79     return data;
80 };
81 
82 export const getOwnEquipment = async () => {
83     const bearer = localStorage.getItem("bearer");
84     const { data } = await axios.get<string>(`${url}Equipment/my-equipment`, {
85         headers: { Authorization: `Bearer ${bearer}` },
86     });
87 
88     return data;
89 };
90 
91 export const getOwnEquipmentInfo = async (equipmentId: string) => {
92     const bearer = localStorage.getItem("bearer");
93     const { data } = await axios.get(
94         `${url}Equipment/my-equipment/${equipmentId}`,
95         {
96             headers: { Authorization: `Bearer ${bearer}` },
97         },
98     );
99 
100     return data;
101 };
102 
103 export const getOwnIngredients = async () => {
104     const bearer = localStorage.getItem("bearer");
105     const { data } = await axios.get<string>(
106         `${url}Ingredient/my-ingredients`,
107         {
108             headers: { Authorization: `Bearer ${bearer}` },
109         },
110     );
111 
112     return data;
113 };
114 
115 export const getOwnRecipes = async () => {
116     const bearer = localStorage.getItem("bearer");
117     const { data } = await axios.get<string>(`${url}Recipe/my-recipes`, {
118         headers: { Authorization: `Bearer ${bearer}` },
119     });
120 
121     return data;
122 };
123 
124 export const updateProfile = async (
125     newFirstName: string,
126     newLastName: string,
127 ) => {
128     const bearer = localStorage.getItem("bearer");
129     const request: UpdateBrewerProfileDto = {
130         firstName: newFirstName,
131         lastName: newLastName,
132     };
133     const { data } = await axios.put<UpdateBrewerProfileDto>(
134         `${url}Profile/edit`,
135         request,
136         {
137             headers: { Authorization: `Bearer ${bearer}` },
138         },
139     );
140 
141     return data;
142 };
143 
144 export const updateConnectionString = async (
145     equipmentId: string,
146     newConnectionString: string,
147 ) => {
148     const bearer = localStorage.getItem("bearer");
149     const request: UpdateConnectionStringDto = {
150         equipmentId: equipmentId,
151         connectionString: newConnectionString,
152     };
153     const { data } = await axios.put(
154         `${url}Brewing/my-equipment/update-string`,
155         request,
156         {
157             headers: { Authorization: `Bearer ${bearer}` },
158         },
159     );
160 
161     return data;
162 };
163 
164 export const getCurrentBrewingStatus = async (equipmentId: string) => {
165     const bearer = localStorage.getItem("bearer");
166 
167     const { data } = await axios.get(
168         `${url}Brewing/brewing-status/${equipmentId}`,
169         {
170             headers: { Authorization: `Bearer ${bearer}` },
171         },
172     );
173 
174     return data;
175 };
176 
177 export const getEquipmentStatus = async (equipmentId: string) => {
178     const bearer = localStorage.getItem("bearer");
179 
180     const { data } = await axios.get(
181         `${url}Brewing/equipment-status/${equipmentId}`,
182         {
183             headers: { Authorization: `Bearer ${bearer}` },
184         },
185     );
186 
187     return data;
188 };
189 
190 export const getEquipmentAvailability = async (equipmentId: string) => {
191     const bearer = localStorage.getItem("bearer");
192 
193     const { data } = await axios.get(
194         `${url}Brewing/equipment-availability/${equipmentId}`,
195         {
196             headers: { Authorization: `Bearer ${bearer}` },
197         },
198     );
199 
200     return data;
201 };
202 
203 export const startNewBrewing = async (
204     recipeId: string,
205     equipmentId: string,
206 ) => {
207     const bearer = localStorage.getItem("bearer");
208     const { data } = await axios.get(
209         `${url}Brewing/start?recipeId=${recipeId}&equipmentId=${equipmentId}`,
210         {
211             headers: { Authorization: `Bearer ${bearer}` },
212         },
213     );
214 
215     return data;
216 };
217 
218 export const abortBrewing = async (equipmentId: string) => {
219     const bearer = localStorage.getItem("bearer");
220     const { data } = await axios.get(`${url}Brewing/abort/${equipmentId}`, {
221         headers: { Authorization: `Bearer ${bearer}` },
222     });
223 
224     return data;
225 };
226 
227 export const getBrewingHistory = async (equipmentId: string) => {
228     const bearer = localStorage.getItem("bearer");
229     const { data } = await axios.get(
230         `${url}Brewing/equipment-brewings/${equipmentId}`,
231         {
232             headers: { Authorization: `Bearer ${bearer}` },
233         },
234     );
235 
236     return data;
237 };
238 
239 export const buyEquipment = async (equipmentId: string) => {
240     const bearer = localStorage.getItem("bearer");
241     const { data } = await axios.get(
242         `${url}Equipment/my-equipment/buy/${equipmentId}`,
243         {
244             headers: { Authorization: `Bearer ${bearer}` },
245         },
246     );
247 
248     return data;
249 };
250 
251 export const deleteEquipment = async (equipmentId: string) => {
252     const bearer = localStorage.getItem("bearer");
253     const { data } = await axios.delete(
254         `${url}Equipment/delete/${equipmentId}`,
255         {
256             headers: { Authorization: `Bearer ${bearer}` },
257         },
258     );
259 
260     return data;
261 };
262 
263 export const updateEquipment = async (newEquipment: UpdateEquipmentDto) => {
264     const bearer = localStorage.getItem("bearer");
265     const { data } = await axios.put(`${url}Equipment/update`, newEquipment, {
266         headers: { Authorization: `Bearer ${bearer}` },
267     });
268 
269     return data;
270 };
271 
272 export const createEquipment = async (newEquipment: CreateEquipmentDto) => {
273     const bearer = localStorage.getItem("bearer");
274     const { data } = await axios.post(`${url}Equipment/create`, newEquipment, {
275         headers: { Authorization: `Bearer ${bearer}` },
276     });
277 
278     return data;
279 };
280 
281 export const deleteRecipe = async (recipeId: string) => {
282     const bearer = localStorage.getItem("bearer");
283     const { data } = await axios.delete(`${url}Recipe/${recipeId}`, {
284         headers: { Authorization: `Bearer ${bearer}` },
285     });
286 
287     return data;
288 };
289 
290 export const updateRecipe = async (newRecipe: UpdateRecipeDto) => {
291     const bearer = localStorage.getItem("bearer");
292     const { data } = await axios.put(`${url}Recipe/edit`, newRecipe, {
293         headers: { Authorization: `Bearer ${bearer}` },
294     });
295 
296     return data;
297 };
298 
299 export const createRecipe = async (newRecipe: CreateRecipeDto) => {
300     const bearer = localStorage.getItem("bearer");
301     const { data } = await axios.post(`${url}Recipe/create`, newRecipe, {
302         headers: { Authorization: `Bearer ${bearer}` },
303     });
304 
305     return data;
306 };
307 
308 export const deleteIngredient = async (ingredientId: string) => {
309     const bearer = localStorage.getItem("bearer");
310     const { data } = await axios.delete(`${url}Ingredient/${ingredientId}`, {
311         headers: { Authorization: `Bearer ${bearer}` },
312     });
313 
314     return data;
315 };
316 
317 export const updateIngredient = async (newIngredient: UpdateIngredientDto) => {
318     const bearer = localStorage.getItem("bearer");
319     const { data } = await axios.put(`${url}Ingredient/update`, newIngredient, {
320         headers: { Authorization: `Bearer ${bearer}` },
321     });
322 
323     return data;
324 };
325 
326 export const createIngredient = async (newIngredient: CreateIngredientDto) => {
327     const bearer = localStorage.getItem("bearer");
328     const { data } = await axios.post(
329         `${url}Ingredient/create`,
330         newIngredient,
331         {
332             headers: { Authorization: `Bearer ${bearer}` },
333         },
334     );
335 
336     return data;
337 };
338 
339 export const buyIngredient = async (ingredientId: string, weight: number) => {
340     const newIngredient = { ingredientId: ingredientId, weight: weight };
341     const bearer = localStorage.getItem("bearer");
342     const { data } = await axios.post(
343         `${url}Ingredient/my-ingredient/buy`,
344         newIngredient,
345         {
346             headers: { Authorization: `Bearer ${bearer}` },
347         },
348     );
349 
350     return data;
351 };
352 
353 export const downloadData = async () => {
354     try {
355         const bearer = localStorage.getItem("bearer");
356 
357         const response = await axios.get(`${url}Data/export`, {
358             headers: {
359                 Authorization: `Bearer ${bearer}`,
360             },
361             responseType: "blob", // Important to handle the binary data
362         });
363 
364         const downloadUrl = window.URL.createObjectURL(
365             new Blob([response.data]),
366         );
367         const link = document.createElement("a");
368         link.href = downloadUrl;
369         link.setAttribute("download", "DbSaved.xlsx");
370         document.body.appendChild(link);
371         link.click();
372     } catch (error) {
373         console.error("Error downloading data:", error);
374     }
375 };
Г.3 Код сторінки із управлінням процесами пивоваріння на обладнанні


1 import React, { useState, useEffect } from "react";
2 import { useParams } from "react-router-dom";
3 import {
4     Container,
5     Typography,
6     Paper,
7     Box,
8     TextField,
9     Button,
10     List,
11     ListItem,
12     ListItemText,
13     ListSubheader,
14 } from "@mui/material";
15 import {
16     getItemsList,
17     getOwnEquipmentInfo,
18     getCurrentBrewingStatus,
19     getEquipmentStatus,
20     getEquipmentAvailability,
21     updateConnectionString,
22     startNewBrewing,
23     abortBrewing,
24     getBrewingHistory,
25 } from "../services/api";
26 import { RecipeDto } from "./RecipeDetails";
27 import { toast } from "react-toastify";
28 import { useTranslation } from "react-i18next";
29 
30 interface BrewingShortInfoDto {
31     equipmentTitle: string;
32     recipeTitle: string;
33     brewingStatus: string;
34     lastUpdateDate: string;
35 }
36 
37 interface BrewerBrewingEquipmentFullInfoDto {
38     id: string;
39     name: string;
40     imgUrl: string;
41     connectionString: string;
42     isBrewing: boolean;
43 }
44 
45 interface EquipmentStatusDto {
46     temperature: number;
47     pressure: number;
48     humidity: number;
49     fullness: number;
50     lastUpdate: string;
51     isBrewing: boolean;
52 }
53 
54 interface BrewingFullInfoDto {
55     id: string;
56     recipeId: string;
57     equipmentTitle: string;
58     recipeTitle: string;
59     brewingStatus: string;
60     lastUpdateDate: string;
61     brewingLogs: BrewingLogDto[];
62     createdAt: string;
63 }
64 
65 interface BrewingLogDto {
66     statusCode: string;
67     message: string;
68     logTime: string;
69 }
70 
71 const MyEquipmentPage: React.FC = () => {
72     const { id } = useParams<{ id: string }>();
73     const [equipment, setEquipment] =
74         useState<BrewerBrewingEquipmentFullInfoDto | null>(null);
75     const [connectionString, setConnectionString] = useState("");
76     const [isAvailable, setIsAvailable] = useState(false);
77     const [isBrewing, setIsBrewing] = useState(false);
78     const [brewingLogs, setBrewingLogs] = useState<string | JSX.Element>("");
79     const [equipmentLogs, setEquipmentLogs] = useState<string | JSX.Element>(
80         "",
81     );
82     const [brewingHistory, setBrewingHistory] = useState<string | JSX.Element>(
83         "",
84     );
85     const [recipes, setRecipes] = useState<RecipeDto[]>([]);
86     const [selectedRecipe, setSelectedRecipe] = useState<RecipeDto | null>(
87         null,
88     );
89     const { t } = useTranslation();
90 
91     useEffect(() => {
92         const fetchInitialData = async () => {
93             try {
94                 const equipmentResponse = await getOwnEquipmentInfo(id!);
95                 setEquipment(equipmentResponse);
96                 setConnectionString(equipmentResponse.connectionString || "");
97 
98                 const recipesResponse = await getItemsList("Recipe");
99                 setRecipes(recipesResponse.data);
100 
101                 checkEquipmentStatus();
102                 fetchBrewingHistory();
103                 const intervalId = setInterval(() => {
104                     checkEquipmentStatus();
105                     fetchBrewingHistory();
106                 }, 3000);
107 
108                 return () => clearInterval(intervalId);
109             } catch (error) {
110                 console.error("Error fetching initial data:", error);
111             }
112         };
113 
114         fetchInitialData();
115     }, [id]);
116 
117     const checkEquipmentStatus = async () => {
118         try {
119             const availabilityResponse = await getEquipmentAvailability(id!);
120             setIsAvailable(availabilityResponse);
121 
122             if (!availabilityResponse) {
123                 setBrewingLogs(
124                     "The device is not available, check your connection string!",
125                 );
126                 setEquipmentLogs(
127                     "The device is not available, check your connection string!",
128                 );
129             } else {
130                 const equipmentStatusResponse = await getEquipmentStatus(id!);
131 
132                 if (equipmentStatusResponse.isBrewing) {
133                     setIsBrewing(true);
134                     const brewingStatusResponse = await getCurrentBrewingStatus(
135                         id!,
136                     );
137                     setBrewingLogs(
138                         <Box>
139                             {brewingStatusResponse.brewingLogs.map(
140                                 (log: any, index: number) => (
141                                     <Typography
142                                         key={index}
143                                         variant="body2"
144                                         sx={{
145                                             fontSize: "1.5rem",
146                                             textAlign: "left",
147                                         }}
148                                     >
149                                         [{log.logTime}] {log.statusCode}:{" "}
150                                         {log.message}
151                                     </Typography>
152                                 ),
153                             )}
154                         </Box>,
155                     );
156                 } else {
157                     setIsBrewing(false);
158                     setBrewingLogs("No brewings yet.");
159                 }
160 
161                 setEquipmentLogs(
162                     <Box>
163                         <Typography
164                             variant="body2"
165                             sx={{ fontSize: "1.5rem", textAlign: "left" }}
166                         >
167                             Temperature: {equipmentStatusResponse.temperature}В°C
168                         </Typography>
169                         <Typography
170                             variant="body2"
171                             sx={{ fontSize: "1.5rem", textAlign: "left" }}
172                         >
173                             Pressure: {equipmentStatusResponse.pressure} Pa
174                         </Typography>
175                         <Typography
176                             variant="body2"
177                             sx={{ fontSize: "1.5rem", textAlign: "left" }}
178                         >
179                             Humidity: {equipmentStatusResponse.humidity} %
180                         </Typography>
181                         <Typography
182                             variant="body2"
183                             sx={{ fontSize: "1.5rem", textAlign: "left" }}
184                         >
185                             Fullness: {equipmentStatusResponse.fullness} %
186                         </Typography>
187                         <Typography
188                             variant="body2"
189                             sx={{ fontSize: "1.5rem", textAlign: "left" }}
190                         >
191                             Last Update: {equipmentStatusResponse.lastUpdate}
192                         </Typography>
193                     </Box>,
194                 );
195             }
196         } catch (error) {
197             console.error("Error checking equipment status:", error);
198         }
199     };
200 
201     const fetchBrewingHistory = async () => {
202         try {
203             const historyResponse = await getBrewingHistory(id!);
204             setBrewingHistory(
205                 <Box
206                     sx={{
207                         backgroundColor: "#000",
208                         color: "#fff",
209                         padding: 2,
210                         height: "300px",
211                         overflowY: "scroll",
212                     }}
213                 >
214                     {historyResponse.map(
215                         (historyItem: BrewingShortInfoDto, index: number) => (
216                             <div key={index}>
217                                 <Typography
218                                     variant="body1"
219                                     sx={{ fontSize: "1.5rem" }}
220                                 >
221                                     Equipment: {historyItem.equipmentTitle}
222                                 </Typography>
223                                 <Typography
224                                     variant="body1"
225                                     sx={{ fontSize: "1.5rem" }}
226                                 >
227                                     Recipe: {historyItem.recipeTitle}
228                                 </Typography>
229                                 <Typography
230                                     variant="body1"
231                                     sx={{ fontSize: "1.5rem" }}
232                                 >
233                                     Status: {historyItem.brewingStatus}
234                                 </Typography>
235                                 <Typography
236                                     variant="body1"
237                                     sx={{ fontSize: "1.5rem" }}
238                                 >
239                                     Last Update: {historyItem.lastUpdateDate}
240                                 </Typography>
241                                 <hr />{" "}
242                             </div>
243                         ),
244                     )}
245                 </Box>,
246             );
247         } catch (error) {
248             console.error("Error fetching brewing history:", error);
249         }
250     };
251 
252     const handleConnectionStringChange = async () => {
253         try {
254             await updateConnectionString(id!, connectionString);
255         } catch (error: any) {
256             if (error.response) {
257                 toast.error(error.response.data.message);
258             }
259         }
260     };
261 
262     const handleRecipeSelect = (recipe: RecipeDto) => {
263         if (selectedRecipe?.id === recipe.id) {
264             setSelectedRecipe(null);
265         } else {
266             setSelectedRecipe(recipe);
267         }
268     };
269 
270     const handleStartBrewing = async () => {
271         if (!selectedRecipe) return;
272 
273         const response = startNewBrewing(selectedRecipe.id, id!);
274         response.catch((error: any) => {
275             if (error.response) {
276                 toast.error(error.response.data.message);
277             }
278         });
279     };
280 
281     const handleAbortBrewing = async () => {
282         try {
283             await abortBrewing(id!);
284         } catch (error: any) {
285             if (error.response) {
286                 toast.error(error.response.data.message);
287             }
288         }
289     };
290 
291     if (!equipment) {
292         return <Typography variant="h4">Loading...</Typography>;
293     }
294 
295     return (
296         <Container style={{ marginTop: "2rem" }}>
297             <Paper sx={{ padding: 4, marginTop: 4 }}>
298                 <Typography variant="h2" gutterBottom>
299                     ({equipment.id.split("-")[0]}) {equipment.name}{" "}
300                     {isBrewing ? "рџџў" : "рџ”ґ"}
301                 </Typography>
302                 <Box
303                     sx={{
304                         display: "flex",
305                         justifyContent: "space-between",
306                         alignItems: "flex-start",
307                         marginTop: 4,
308                     }}
309                 >
310                     <Box sx={{ flex: 1, marginRight: 2 }}>
311                         <Typography variant="h3" gutterBottom>
312                             {t("connectionString")}
313                         </Typography>
314                         <TextField
315                             value={connectionString}
316                             onChange={(e) =>
317                                 setConnectionString(e.target.value)
318                             }
319                             fullWidth
320                             margin="normal"
321                             InputProps={{ style: { fontSize: "1.5rem" } }}
322                         />
323                         <Button
324                             variant="contained"
325                             color="primary"
326                             onClick={handleConnectionStringChange}
327                             sx={{ fontSize: "1.5rem" }}
328                         >
329                             {t("updateConnectionString")}
330                         </Button>
331                     </Box>
332                     <Box sx={{ flex: 1 }}>
333                         <Box
334                             sx={{
335                                 backgroundColor: "#000",
336                                 color: "#fff",
337                                 padding: 2,
338                                 height: "150px",
339                                 overflowY: "scroll",
340                                 marginBottom: 2,
341                             }}
342                         >
343                             <Typography variant="h5" gutterBottom>
344                                 {t("currentBrewingStatus")}
345                             </Typography>
346                             <Box sx={{ fontSize: "1.5rem", textAlign: "left" }}>
347                                 {brewingLogs}
348                             </Box>
349                         </Box>
350                         <Box
351                             sx={{
352                                 backgroundColor: "#000",
353                                 color: "#fff",
354                                 padding: 2,
355                                 height: "150px",
356                                 overflowY: "scroll",
357                             }}
358                         >
359                             <Typography variant="h5" gutterBottom>
360                                 {t("equipmentStatus")}
361                             </Typography>
362                             <Box sx={{ fontSize: "1.5rem", textAlign: "left" }}>
363                                 {equipmentLogs}
364                             </Box>
365                         </Box>
366                     </Box>
367                 </Box>
368                 <Box
369                     sx={{
370                         display: "flex",
371                         justifyContent: "space-between",
372                         marginTop: 4,
373                     }}
374                 >
375                     <Box sx={{ flex: 1 }}>
376                         <Typography variant="h3" gutterBottom>
377                             {t("chooseRecipe")}
378                         </Typography>
379                         <List>
380                             {recipes.map((recipe) => (
381                                 <ListItem
382                                     button
383                                     key={recipe.id}
384                                     onClick={() => handleRecipeSelect(recipe)}
385                                     selected={selectedRecipe?.id === recipe.id}
386                                 >
387                                     <ListItemText
388                                         primary={recipe.title}
389                                         primaryTypographyProps={{
390                                             style: { fontSize: "2.5rem" },
391                                         }}
392                                     />
393                                 </ListItem>
394                             ))}
395                         </List>
396                         {selectedRecipe && (
397                             <Box sx={{ textAlign: "center", marginTop: 2 }}>
398                                 <Typography
399                                     variant="h4"
400                                     sx={{ fontSize: "2.5rem" }}
401                                 >
402                                     {selectedRecipe.title}
403                                 </Typography>
404                                 <Box>
405                                     {selectedRecipe.ingredients.map(
406                                         (ingredient) => (
407                                             <Typography
408                                                 key={ingredient.id}
409                                                 variant="body1"
410                                                 sx={{ fontSize: "2rem" }}
411                                             >
412                                                 {ingredient.name} -{" "}
413                                                 {ingredient.weight}g
414                                             </Typography>
415                                         ),
416                                     )}
417                                 </Box>
418                                 <Button
419                                     variant="contained"
420                                     color="primary"
421                                     onClick={handleStartBrewing}
422                                     disabled={isBrewing}
423                                     sx={{ marginTop: 2, fontSize: "1.5rem" }}
424                                 >
425                                     {t("startBrewing")}
426                                 </Button>
427                                 <Button
428                                     variant="contained"
429                                     color="secondary"
430                                     onClick={handleAbortBrewing}
431                                     disabled={!isBrewing}
432                                     sx={{
433                                         marginTop: 2,
434                                         fontSize: "1.5rem",
435                                         marginLeft: 2,
436                                     }}
437                                 >
438                                     {t("abort")}
439                                 </Button>
440                             </Box>
441                         )}
442                     </Box>
443                     <Box sx={{ flex: 1, marginLeft: 2, overflowY: "hidden" }}>
444                         <Typography variant="h3" gutterBottom>
445                         {t("brewingHistory")}
446                         </Typography>
447                         <Box
448                             sx={{
449                                 backgroundColor: "#000",
450                                 color: "#fff",
451                                 padding: 0,
452                                 height: "300px",
453                                 textAlign: "left",
454                             }}
455                         >
456                             {brewingHistory}
457                         </Box>
458                     </Box>
459                 </Box>
460             </Paper>
461         </Container>
462     );
463 };
464 
465 export default MyEquipmentPage;
